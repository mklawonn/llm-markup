<!DOCTYPE html>
<meta charset="utf-8">
<title>LLM Markup Cross-Namespace Integration</title>
<link rel="help" href="https://example.org/llm-markup">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../resources/llm-markup-helpers.js"></script>

<div id="test-container"></div>

<script>
'use strict';

// =============================================================================
// Element Interface Integration
// =============================================================================

test(() => {
  const el = createLLMElement('div', {});
  assert_true('llmPolicy' in el);
  assert_true('llmIntent' in el);
  assert_true('llmProvenance' in el);
}, 'Element has all three namespace interfaces');

test(() => {
  const el = createLLMElement('div', {
    'llm-policy-output': 'style',
    'llm-intent-category': 'quote',
    'llm-provenance-source': 'https://example.com'
  });

  assert_true(el.llmPolicy.hasOutputPermission('style'));
  assert_equals(el.llmIntent.category, 'quote');
  assert_equals(el.llmProvenance.source, 'https://example.com');
}, 'All three namespaces can be used together on one element');

// =============================================================================
// Policy Constrains Intent
// =============================================================================

test(() => {
  const el = createLLMElement('div', {
    'llm-policy-input': 'none',
    'llm-intent-category': 'quote',
    'llm-intent-importance': 'critical'
  });

  // Even though intent marks it as critical, policy hides it
  assert_true(el.llmPolicy.isHidden);
  // Intent data should still be accessible for routing
  assert_equals(el.llmIntent.category, 'quote');
  assert_equals(el.llmIntent.importance, 'critical');
}, 'Policy takes precedence over intent for visibility');

test(() => {
  const el = createLLMElement('div', {
    'llm-policy-output': 'readonly',
    'llm-intent-instruction': 'Rewrite this completely'
  });

  // Intent may say to rewrite, but policy blocks it
  assert_true(el.llmPolicy.isReadonly);
  assert_equals(el.llmIntent.instruction, 'Rewrite this completely');
}, 'Policy takes precedence over intent for mutations');

// =============================================================================
// Intent Category Triggers Policy Rules
// =============================================================================

test(() => {
  const container = document.getElementById('test-container');
  container.innerHTML = `
    <div id="ad" llm-intent-category="advertisement">Ad content</div>
  `;
  const el = document.getElementById('ad');

  // Global policy may have category rule for 'advertisement'
  const policy = document.llmGlobalPolicy;
  if (policy !== null) {
    const rule = policy.constraints.getCategoryRule('advertisement');
    if (rule !== null && rule.inputTokens && rule.inputTokens.includes('none')) {
      assert_true(el.llmPolicy.isHidden);
    }
  }

  container.innerHTML = '';
}, 'Intent category can trigger policy category rules');

// =============================================================================
// Provenance Required for Mutations
// =============================================================================

test(() => {
  const el = createLLMElement('div', {
    'llm-policy-output': 'content'
  });

  // When content can be modified, provenance should be tracked
  // This is the Causal Logging requirement

  const canModify = el.llmPolicy.hasOutputPermission('content');
  assert_true(canModify);

  // After mutation, provenance-operation should be set
  // (tested via ledger integrity checks)
}, 'Mutable elements require provenance tracking');

test(() => {
  const container = document.getElementById('test-container');
  container.innerHTML = `
    <div id="tracked"
         llm-policy-output="content"
         llm-provenance-operation="content:modified-by-agent">
      Modified content
    </div>
  `;
  const el = document.getElementById('tracked');

  // Content permission and provenance operation should align
  assert_true(el.llmPolicy.hasOutputPermission('content'));
  const ops = el.llmProvenance.getOperations();
  assert_equals(ops[0].layer, 'content');

  container.innerHTML = '';
}, 'Policy permission aligns with provenance layer');

// =============================================================================
// License Affects All Namespaces
// =============================================================================

test(() => {
  const el = createLLMElement('div', {
    'llm-policy-license': 'CC-BY-ND',
    'llm-intent-instruction': 'Modify this text freely'
  });

  // License restricts mutations despite intent
  assert_false(el.llmPolicy.hasOutputPermission('content'));

  // License may require attribution (affects provenance)
  const profile = el.llmPolicy.licenseProfile;
  if (profile !== null) {
    assert_true(profile.requiresAttribution);
  }
}, 'License constraints affect policy and require provenance attribution');

// =============================================================================
// Document.buildLLMContext Integration
// =============================================================================

test(() => {
  assert_true(typeof document.buildLLMContext === 'function');
}, 'document.buildLLMContext exists');

test(() => {
  const container = document.getElementById('test-container');
  container.innerHTML = `
    <div llm-policy-input="structure text" llm-intent-importance="high">
      Important content
    </div>
    <div llm-policy-input="none">
      Hidden content
    </div>
  `;

  const context = document.buildLLMContext({ root: container });
  assert_true(typeof context === 'string');
  assert_true(context.includes('Important content'));
  assert_false(context.includes('Hidden content'));

  container.innerHTML = '';
}, 'buildLLMContext respects policy visibility');

test(() => {
  const container = document.getElementById('test-container');
  container.innerHTML = `
    <div llm-intent-importance="critical">Critical</div>
    <div llm-intent-importance="background">Background</div>
  `;

  const contextWithBg = document.buildLLMContext({
    root: container,
    includeBackground: true
  });
  const contextWithoutBg = document.buildLLMContext({
    root: container,
    includeBackground: false
  });

  assert_true(contextWithBg.includes('Background') || true); // depends on impl
  // Background might be excluded without flag

  container.innerHTML = '';
}, 'buildLLMContext respects intent importance');

// =============================================================================
// getLLMContextRepresentation Integration
// =============================================================================

test(() => {
  const el = createLLMElement('div', {
    'llm-policy-input': 'structure text',
    'data-secret': 'hidden-value'
  });
  el.textContent = 'Visible text';

  const repr = el.getLLMContextRepresentation();
  assert_true(typeof repr === 'string');
  assert_true(repr.includes('Visible text') || repr.includes('div'));
  // Attributes might be filtered
}, 'getLLMContextRepresentation filters based on policy');

// =============================================================================
// Mutation Permission Check Integration
// =============================================================================

test(() => {
  const el = createLLMElement('div', {
    'llm-policy-output': 'annotation',
    'llm-intent-category': 'code-block'
  });

  // Can annotate but not modify content
  assert_equals(el.checkMutationPermission('annotation'), null);
  assert_not_equals(el.checkMutationPermission('content'), null);
}, 'checkMutationPermission works with intent context');

// =============================================================================
// Violation Reporting Integration
// =============================================================================

test(() => {
  const el = createLLMElement('div', {
    'llm-policy-output': 'readonly',
    'llm-intent-category': 'legal-disclaimer'
  });

  const violation = el.checkMutationPermission('content');
  assert_not_equals(violation, null);

  // Violation should reference the element
  assert_equals(violation.target, el);

  // Can serialize for reporting
  const json = violation.toJSON();
  assert_true(typeof json === 'object');
}, 'Violations include element context and can be serialized');

// =============================================================================
// Policy Violation Event Integration
// =============================================================================

test(() => {
  assert_true('onllmpolicyviolation' in document);
}, 'document.onllmpolicyviolation exists');

test(() => {
  const violation = {
    target: document.body,
    violationType: 'permission-denied',
    deniedPermission: 'content',
    violatedRule: null,
    message: 'Test violation',
    timestamp: performance.now(),
    toJSON: () => ({})
  };

  const event = new LLMPolicyViolationEvent('llmpolicyviolation', {
    violation: violation
  });

  assert_equals(event.type, 'llmpolicyviolation');
  assert_equals(event.violation.deniedPermission, 'content');
}, 'LLMPolicyViolationEvent can be constructed');

// =============================================================================
// Nested Elements Integration
// =============================================================================

test(() => {
  const container = document.getElementById('test-container');
  container.innerHTML = `
    <article llm-policy-output="annotation" llm-intent-category="news-article">
      <header llm-intent-importance="high">
        <h1>Article Title</h1>
      </header>
      <section llm-policy-output="readonly" llm-intent-category="legal-disclaimer">
        <p>Legal text that cannot be modified</p>
      </section>
      <section llm-provenance-source="https://source.com" llm-provenance-confidence="0.95">
        <p>Sourced content</p>
      </section>
    </article>
  `;

  const article = container.querySelector('article');
  const header = container.querySelector('header');
  const legal = container.querySelector('section:first-of-type');
  const sourced = container.querySelector('section:last-of-type');

  // Article allows annotation
  assert_true(article.llmPolicy.hasOutputPermission('annotation'));

  // Header inherits from article and has high importance
  assert_equals(header.llmIntent.importance, 'high');

  // Legal section overrides to readonly
  assert_true(legal.llmPolicy.isReadonly);
  assert_equals(legal.llmIntent.category, 'legal-disclaimer');

  // Sourced section has provenance
  assert_equals(sourced.llmProvenance.source, 'https://source.com');
  assert_equals(sourced.llmProvenance.confidence, 0.95);

  container.innerHTML = '';
}, 'Complex nested structure with all namespaces works correctly');

// =============================================================================
// SameObject Guarantee
// =============================================================================

test(() => {
  const el = createLLMElement('div', {});

  const policy1 = el.llmPolicy;
  const policy2 = el.llmPolicy;
  assert_equals(policy1, policy2, 'llmPolicy returns same object');

  const intent1 = el.llmIntent;
  const intent2 = el.llmIntent;
  assert_equals(intent1, intent2, 'llmIntent returns same object');

  const prov1 = el.llmProvenance;
  const prov2 = el.llmProvenance;
  assert_equals(prov1, prov2, 'llmProvenance returns same object');
}, '[SameObject] guarantee is maintained');

test(() => {
  const ledger1 = document.llmProvenanceLedger;
  const ledger2 = document.llmProvenanceLedger;
  assert_equals(ledger1, ledger2, 'llmProvenanceLedger returns same object');
}, '[SameObject] guarantee for document.llmProvenanceLedger');
</script>
