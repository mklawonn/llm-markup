<!DOCTYPE html>
<meta charset="utf-8">
<title>LLM Policy Output Token Parsing</title>
<link rel="help" href="https://example.org/llm-markup#llm-policy-output">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../../resources/llm-markup-helpers.js"></script>

<div id="test-container"></div>

<script>
'use strict';

// =============================================================================
// Basic Token Parsing
// =============================================================================

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'style' });
  assert_array_equals(el.llmPolicy.outputTokens, ['style']);
}, 'Single output token is parsed correctly');

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'style annotation content' });
  assert_array_equals_unordered(el.llmPolicy.outputTokens, ['style', 'annotation', 'content']);
}, 'Multiple space-separated output tokens are parsed correctly');

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'style  content   data' });
  assert_array_equals_unordered(el.llmPolicy.outputTokens, ['style', 'content', 'data']);
}, 'Multiple spaces between tokens are normalized');

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'STYLE CONTENT' });
  assert_array_equals_unordered(el.llmPolicy.outputTokens, ['style', 'content']);
}, 'Token parsing is case-insensitive');

// =============================================================================
// All Valid Tokens
// =============================================================================

for (const token of VALID_OUTPUT_TOKENS) {
  test(() => {
    const el = createLLMElement('div', { 'llm-policy-output': token });
    if (token === 'mutable') {
      assert_true(el.llmPolicy.isMutable, `Token '${token}' grants full access`);
    } else {
      assert_true(
        el.llmPolicy.outputTokens.includes(token),
        `Token '${token}' should be recognized`
      );
    }
  }, `Valid output token '${token}' is accepted`);
}

// =============================================================================
// Special Token: 'readonly' (Default)
// =============================================================================

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'readonly' });
  assert_true(el.llmPolicy.isReadonly);
  assert_false(el.llmPolicy.hasOutputPermission('style'));
  assert_false(el.llmPolicy.hasOutputPermission('content'));
}, "'readonly' token blocks all mutations");

test(() => {
  const el = createLLMElement('div', {});
  // Per spec: default is readonly
  assert_true(el.llmPolicy.isReadonly);
}, "Default output policy is 'readonly'");

// =============================================================================
// Special Token: 'mutable'
// =============================================================================

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'mutable' });
  assert_true(el.llmPolicy.isMutable);
  assert_true(el.llmPolicy.hasOutputPermission('style'));
  assert_true(el.llmPolicy.hasOutputPermission('content'));
  assert_true(el.llmPolicy.hasOutputPermission('data'));
  assert_true(el.llmPolicy.hasOutputPermission('append'));
}, "'mutable' token grants all permissions");

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'readonly mutable' });
  // 'mutable' should override 'readonly' when both present
  assert_true(el.llmPolicy.isMutable);
}, "'mutable' overrides 'readonly' when both present");

// =============================================================================
// Token Combinations
// =============================================================================

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'style annotation' });
  assert_true(el.llmPolicy.hasOutputPermission('style'));
  assert_true(el.llmPolicy.hasOutputPermission('annotation'));
  assert_false(el.llmPolicy.hasOutputPermission('content'));
  assert_false(el.llmPolicy.hasOutputPermission('data'));
}, 'Permission set is union of specified tokens');

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'interaction' });
  // 'interaction' implies ability to modify class/style per spec
  assert_true(el.llmPolicy.hasOutputPermission('interaction'));
}, "'interaction' token grants behavioral layer access");

// =============================================================================
// Invalid Tokens
// =============================================================================

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'invalid-token' });
  assert_false(el.llmPolicy.outputTokens.includes('invalid-token'));
  // Should fall back to readonly behavior
  assert_true(el.llmPolicy.isReadonly);
}, 'Invalid tokens are ignored, falls back to readonly');

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'style invalid content' });
  assert_true(el.llmPolicy.outputTokens.includes('style'));
  assert_true(el.llmPolicy.outputTokens.includes('content'));
  assert_false(el.llmPolicy.outputTokens.includes('invalid'));
}, 'Invalid tokens are filtered while valid tokens are preserved');

// =============================================================================
// Duplicate Tokens
// =============================================================================

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'style style content style' });
  const styleCount = el.llmPolicy.outputTokens.filter(t => t === 'style').length;
  assert_equals(styleCount, 1, 'Duplicates are deduplicated');
}, 'Duplicate tokens are deduplicated');

// =============================================================================
// Attribute Reflection
// =============================================================================

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'style content' });
  assert_equals(el.llmPolicy.outputAttribute, 'style content');
}, 'outputAttribute reflects the raw attribute value');

// =============================================================================
// hasOutputPermission Method
// =============================================================================

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'style annotation' });
  assert_true(el.llmPolicy.hasOutputPermission('style'));
  assert_true(el.llmPolicy.hasOutputPermission('annotation'));
  assert_false(el.llmPolicy.hasOutputPermission('content'));
  assert_false(el.llmPolicy.hasOutputPermission('interaction'));
  assert_false(el.llmPolicy.hasOutputPermission('layout'));
  assert_false(el.llmPolicy.hasOutputPermission('data'));
  assert_false(el.llmPolicy.hasOutputPermission('append'));
}, 'hasOutputPermission correctly reports token presence');

// =============================================================================
// Token-Specific Permissions
// =============================================================================

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'style' });
  // Style should only allow class and style attribute changes
  assert_true(el.llmPolicy.hasOutputPermission('style'));
  assert_false(el.llmPolicy.hasOutputPermission('content'));
}, "'style' token grants presentation layer only");

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'layout' });
  // Layout should only allow reordering children
  assert_true(el.llmPolicy.hasOutputPermission('layout'));
  assert_false(el.llmPolicy.hasOutputPermission('content'));
}, "'layout' token grants structural reordering only");

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'annotation' });
  // Annotation allows wrapping text but not changing it
  assert_true(el.llmPolicy.hasOutputPermission('annotation'));
  assert_false(el.llmPolicy.hasOutputPermission('content'));
}, "'annotation' token grants non-destructive wrapping only");

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'content' });
  // Content allows text modification
  assert_true(el.llmPolicy.hasOutputPermission('content'));
  assert_false(el.llmPolicy.hasOutputPermission('style'));
}, "'content' token grants text layer only");

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'data' });
  // Data allows form values, data-*, meta content
  assert_true(el.llmPolicy.hasOutputPermission('data'));
  assert_false(el.llmPolicy.hasOutputPermission('content'));
}, "'data' token grants machine-readable payload only");

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'append' });
  // Append allows adding new children at end
  assert_true(el.llmPolicy.hasOutputPermission('append'));
  assert_false(el.llmPolicy.hasOutputPermission('content'));
}, "'append' token grants additive structure only");

// =============================================================================
// isReadonly and isMutable Properties
// =============================================================================

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'readonly' });
  assert_true(el.llmPolicy.isReadonly);
  assert_false(el.llmPolicy.isMutable);
}, 'isReadonly is true for readonly-only element');

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'style content' });
  assert_false(el.llmPolicy.isReadonly);
  assert_false(el.llmPolicy.isMutable);
}, 'isReadonly is false when other permissions are granted');

test(() => {
  const el = createLLMElement('div', { 'llm-policy-output': 'mutable' });
  assert_false(el.llmPolicy.isReadonly);
  assert_true(el.llmPolicy.isMutable);
}, 'isMutable is true only for mutable token');
</script>
