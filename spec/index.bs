<pre class='metadata'>
Title: Web Agent Markup (WAM)
Shortname: web-agent-markup
Level: 1
Status: ED
Group: Web Agent Markup Community Group
URL: https://example.org/web-agent-markup
Editor: [Your Name/Organization]
Abstract: A declarative transformation contract embedded in HTML to govern LLM agent behavior.
Markup Shorthands: markdown yes
</pre>

# Namespaces and Attributes

## The WAM-Intent Namespace

The `wam-intent` namespace defines soft constraints and semantic signals that help the User Agent construct a deterministic context for the LLM. Unlike policy attributes, these do not strictly enforce visibility or mutability by default, but provide metadata that can be targeted by policies.

### The wam-policy-license attribute
Specifies the usage license for the content, acting as a policy macro that enforces rights and restrictions.

*   **Syntax:** `wam-policy-license="<SPDX-Identifier>"`
*   **Purpose:** Machine-readable declaration of rights (e.g., `CC-BY-4.0`, `MIT`, `GPL-3.0`). The User Agent MUST enforce the terms associated with the license (e.g., restricting commercial use, requiring `wam-provenance-citation`, or enforcing copyleft on output).

## The WAM-Provenance Namespace

The `wam-provenance` namespace functions as the DOM-visible face of the **Record phase** in the Tool Lifecycle Model (§11). After every successful mutation tool call, the User Agent MUST update the target element's provenance attributes and write a corresponding Provenance Ledger entry as a single atomic operation. The attributes in this namespace serve a dual purpose: they are readable by authors and page scripts as an interchange format, and they are the authoritative input to the `wam_inspect_provenance` MCP tool. The User Agent is always the **append authority** — authors MUST NOT modify these attributes after initial page load; any such modification constitutes a tamper event (§9.5).

See §9 for the full normative Record phase processing model.

### The wam-provenance-source attribute
Specifies the canonical origin URI of the content chunk.

*   **Syntax:** `wam-provenance-source="<URI>"`
*   **Purpose:** Tracks where the information came from (e.g., `https://wikipedia.org`, `urn:internal:knowledge-base`). Used for linking citations.
*   **Record phase role:** Authors MAY set this attribute on original content to declare its source. For content produced by delegated generation (e.g., when the UA calls an external service to produce a value), the User Agent SHOULD set this attribute to a UA-defined provenance URI identifying the generating model and session. The User Agent MUST NOT overwrite an author-supplied value; when the author-supplied value is present and the UA also has a source to record, the UA MUST record its source URI in the Provenance Ledger entry (`generatingModelId` / `orchestratingModelId` fields) rather than in the DOM attribute.
*   **Tool:** `wam_inspect_provenance` returns this field as `source` in the element's provenance object.

### The wam-provenance-operation attribute
The primary Record phase output: an append-only DOM ledger of transformations applied to the element.

*   **Syntax:** `wam-provenance-operation="<layer>:<explanation> ..."`
*   **Format:** A space-separated list of pairs, where `<layer>` is one of `content`, `style`, `interaction`, `topology`, `data`, or `intent`, and `<explanation>` is a succinct, hyphenated summary of the rationale.
*   **Example:** `content:summarized-text style:highlighted-warnings`
*   **Purpose:** Provides a granular audit trail of *why* and *how* the Agent modified the node.
*   **Record phase role:** After every mutation tool call completes, the User Agent MUST atomically append a `<layer>:<explanation>` token to this attribute (see §9.1). Authors MAY pre-populate this attribute on AI-pre-processed content delivered from the server; the UA treats pre-existing entries as baseline provenance and MUST NOT remove them.
*   **Tool:** `wam_inspect_provenance` returns the full operation history as a parsed list. Each mutation tool's Record phase targets this attribute.

### The wam-provenance-confidence attribute
Expresses the generating agent's certainty in the accuracy of the content.

*   **Syntax:** `wam-provenance-confidence="<0.0-1.0>"`
*   **Purpose:** Allows the User Agent to flag low-confidence information (e.g., hallucination warnings) or high-confidence facts in the UI.
*   **Record phase role:** The User Agent MAY set this to a default high value (e.g., `1.0`) for mutations where the orchestrating LLM supplied the value directly. For mutations produced by delegated generation (where a `generatingModelId` differs from the `orchestratingModelId`), the User Agent SHOULD set this to the generating model's expressed confidence if available, or `null` if not determinable. The value is set once per mutation; subsequent mutations to the same element SHOULD update the attribute only if confidence changes.
*   **Tool:** `wam_inspect_provenance` returns this field as `confidence`. The UI SHOULD render a visual indicator based on this value (§9.8).

### The wam-provenance-citation attribute
Specifies the human-readable attribution label for the source.

*   **Syntax:** `wam-provenance-citation="<string>"`
*   **Purpose:** Defines the text to display for attribution (e.g., "[1]", "TechRadar", "Jane Doe"). Replaces the legacy `wam-provenance-attribution` attribute.
*   **Record phase role:** When an element's effective `wam-policy-license` has `requiresAttribution: true`, the User Agent MUST set or verify this attribute as part of the Record phase for any mutation affecting that element. If no citation is available, the User Agent MUST block the mutation and return a structured error rather than recording an uncited mutation on attributed content (§6.5).
*   **Tool:** `wam_inspect_provenance` returns this field as `citation`.

## The WAM-Intent Namespace

The `wam-intent` namespace defines soft constraints and semantic signals that help the User Agent construct a deterministic context for the LLM. Unlike policy attributes, these do not strictly enforce visibility or mutability by default, but provide metadata that can be targeted by policies.

In the Tool Lifecycle Model (§11), intent attributes are fully resolved during **Phase 1: Initialization** — they populate the Mutable Element Manifest with semantic metadata that the LLM uses when deciding how to interact with each element, and they gate the exposure of `wam_invoke` in `tools/list`. Two roles:

*   **Tool Availability Signals** (`wam-intent-function`, `wam-intent-workflow`): Gate the exposure of the `wam_invoke` tool in `tools/list`. Each recognized value causes a `wam_invoke` variant to be offered to the orchestrating LLM.
*   **Manifest Metadata** (`wam-intent-category`, `wam-intent-description`, `wam-intent-importance`, `wam-intent-entity`): Populate the element's Mutable Element Manifest entry with semantic context the LLM reads during session initialization.

See §8 for the full normative processing model.

### The wam-intent-category attribute
Assigns a semantic category to a node, allowing it to be targeted by Global Policy rules or specific LLM instructions.

*   **Syntax:** `wam-intent-category="<string>"`
*   **Purpose:** Provides a stable, semantic label (e.g., "quote", "advertisement", "navigation") independent of CSS classes or visual presentation.
*   **Manifest role:** The category value is included in the element's Mutable Element Manifest entry, giving the LLM semantic context about the element's type before deciding how to interact with it.
*   **Policy role:** Acts as the routing key for Global Policy `category-rules` (§2) and category-based conflict resolution (§2). `wam-intent-category` is the mechanism by which policy rules target element semantics rather than brittle CSS selectors.
*   **Tool availability:** Does not gate any specific MCP tool.

### The wam-intent-description attribute
Provides a developer-authored free-form description of an element's purpose or context.

*   **Syntax:** `wam-intent-description="<string>"`
*   **Purpose:** Allows the page author to communicate to the LLM what an element is, what it is for, or what context is relevant when interacting with it. Unlike `wam-intent-category`, which provides a machine-readable label for policy routing, `wam-intent-description` is prose text intended to be read by the LLM — analogous to `alt` text for images. It describes the element rather than directing the LLM's behaviour; it is not a prompt or instruction.
*   **Manifest role:** Included in the element's Mutable Element Manifest entry as `intent.description`, delivered to the LLM at session initialization.
*   **Tool availability:** Does not gate any specific MCP tool.

**Examples:**

```html
<!-- Content provenance context -->
<section wam-intent-description="User-submitted comment. Content is unmoderated and may be informal.">

<!-- Business context the LLM needs -->
<div wam-intent-description="Subscription upgrade offer. The user has already accepted the base plan pricing.">

<!-- Accuracy caveat -->
<p wam-intent-description="Auto-generated product summary. Not manually reviewed for accuracy.">

<!-- Navigation semantics -->
<nav wam-intent-description="Primary site navigation. Links lead to top-level sections only.">
```

### The wam-intent-importance attribute
Specifies the relative priority of the content within the document topology.

*   **Syntax:** `wam-intent-importance="critical|high|normal|low|background"`
*   **Purpose:** Guides the User Agent in prioritizing content for the LLM context. `critical` content MUST be preserved if token limits are reached, while `background` content MAY be discarded.
*   **Manifest role:** The UA MUST order elements in the Mutable Element Manifest by importance during session initialization: `critical` > `high` > `normal` > `low` > `background`. When token limits require truncation, elements are dropped from the tail of this ordering.
*   **Tool availability:** Does not gate any specific MCP tool.

### The wam-intent-entity attribute
Links the content to a specific real-world entity for disambiguation.

*   **Syntax:** `wam-intent-entity="<URI>"`
*   **Purpose:** Provides a canonical reference (e.g., Wikidata ID, Schema.org URL) to ground the LLM's understanding of named entities.
*   **Manifest role:** Populates the `intent.entity` field in the element's Mutable Element Manifest entry, allowing the LLM to reason about entity identity and de-duplicate or correlate content across elements.
*   **Tool availability:** Does not gate any specific MCP tool.

### The wam-intent-function attribute
Defines the interactive purpose of an element.

*   **Syntax:** `wam-intent-function="<string>"`
*   **Purpose:** Semantic label for interactive controls (e.g., "search", "submit"). See the Standardized Lexicon for normative terms. Custom values are accepted.
*   **Tool availability signal:** The User Agent MUST expose the `wam_invoke` tool in `tools/list` for this element, with the `action` parameter constrained to the value of this attribute. If the value appears in the Standardized Lexicon, the tool description MUST include the Optimized System Prompt for that action. Multiple space-separated values MAY be specified; each causes a separate `wam_invoke` entry or an `action` enum containing all values.
*   **Note:** `wam_invoke` is only meaningful when `wam-policy-output` permits `interaction`.

### The wam-intent-workflow attribute
Defines the role of an element within a multi-step process.

*   **Syntax:** `wam-intent-workflow="<string>"`
*   **Purpose:** Semantic label for workflow states (e.g., "step", "prerequisite"). See the Standardized Lexicon for normative terms. Custom values are accepted.
*   **Tool availability signal:** The User Agent MUST expose the `wam_invoke` tool with the `stage` parameter constrained to the value of this attribute. Workflow values provide the orchestrating LLM with a process-aware interaction surface, enabling it to call `wam_invoke` with awareness of where this element sits in a multi-step flow.
*   **Note:** `wam_invoke` is only meaningful when `wam-policy-output` permits `interaction`.

The `wam-policy` namespace defines hard constraints that a conforming User Agent MUST enforce. These are split into three primary attributes to govern the flow of information and mutations.

### The wam-policy-input attribute
Governs the flow of data from the DOM to the Language Model (Visibility). This attribute accepts a **space-separated list** of allowed information channels. The User Agent MUST construct the context using the union of these channels.

*   **`none` (Default):** The node is completely hidden from the LLM.
*   **`structure`:** The LLM may see the element and its attributes (subject to filtering), but not its text content or children.
*   **`text`:** The LLM may see the text content of the node.
*   **`attributes`:** The LLM may see the attributes of the node.
*   **`media`:** The LLM may see media content (images, audio, video).
*   **`all`:** Shorthand for `structure text attributes media`.

**Example:** `wam-policy-input="structure text"` creates a "Masked" view where the structure and text are visible, but attributes (like PII in `data-user-id`) are hidden.

### The wam-policy-output attribute
Governs the flow of mutations from the Language Model to the DOM (Enforcement). This attribute accepts a **space-separated list** of permission tokens. The User Agent MUST grant the union of all permissions specified.

*   **`readonly` (Default):** No mutations are permitted.
*   **`style`:** Grants permission to modify the Presentation Layer (CSS/Classes).
*   **`interaction`:** Grants permission to modify the Interaction Layer (Scripts/Event Handlers/State).
*   **`layout`:** Grants permission to reorder child nodes (formerly `reorder-only`).
*   **`annotation`:** Grants permission to wrap text nodes without changing content.
*   **`content`:** Grants permission to modify the Content Layer (Text).
*   **`data`:** Grants permission to modify Machine-Readable Payloads (Values, Data Attributes).
*   **`append`:** Grants permission to insert new nodes.
*   **`intent`:** Grants permission to set or update the element's `wam-intent-*` metadata attributes via `wam_set_intent`.
*   **`mutable`:** Shorthand for all permissions.

**Example:** `wam-policy-output="style annotation"` allows highlighting and styling but prevents text alteration.

### The wam-policy-memory attribute
Governs the persistence of interaction data (Retention). This attribute accepts a **space-separated list** of allowed storage scopes.

*   **`none` (Default):** Ephemeral processing only.
*   **`session`:** Data may be retained for the duration of the current browsing session.
*   **`user`:** Data may be stored in the user's long-term profile (e.g., "Remember I like dark mode").
*   **`training`:** Data may be used to train or fine-tune the global model.

**Example:** `wam-policy-memory="session user"` allows personalization but prohibits using the data for model training.

# Global Policy

A server MAY provide a global policy via a JSON-encoded payload. This payload defines default behaviors and immutable constraints for the entire document.

## Policy Delivery

The Global Policy MAY be delivered via HTTP response header, HTML meta tag, or both. When multiple sources are present, the User Agent MUST apply **layered precedence** where the HTTP header establishes authoritative constraints and the meta tag can only add further restrictions.

### HTTP Response Header

The server MAY deliver the Global Policy via the `WAM-Policy` HTTP response header.

**Syntax:**

```http
WAM-Policy: <json-policy>
```

**Example:**

```http
HTTP/1.1 200 OK
Content-Type: text/html
WAM-Policy: {"defaults":{"wam-policy-output":["readonly"]},"constraints":{"block-selectors":[".secret"]}}
```

For policies exceeding practical header size limits (~8KB), the server SHOULD use the `WAM-Policy-Src` header to reference an external policy file.

**External Policy Reference:**

```http
WAM-Policy-Src: /.well-known/wam-policy.json
```

The User Agent MUST fetch the referenced policy file before allowing any LLM interaction with the document. The referenced file MUST be same-origin or served with appropriate CORS headers (`Access-Control-Allow-Origin`).

### HTML Meta Tag

The document MAY include a Global Policy via a `<meta>` tag in the `<head>` element.

**Syntax:**

```html
<meta name="wam-policy" content="<json-policy>">
```

**Example:**

```html
<head>
  <meta name="wam-policy" content='{"defaults":{"wam-policy-memory":["none"]}}'>
</head>
```

For external policy files:

```html
<meta name="wam-policy-src" content="/.well-known/wam-policy.json">
```

### Delivery Precedence

When both HTTP header and meta tag provide policy, the User Agent MUST apply the following precedence rules:

1.  **HTTP Header Authority:** The policy delivered via HTTP header (or `WAM-Policy-Src`) establishes the authoritative baseline. This policy is considered **tamper-proof** as it cannot be modified by page scripts.

2.  **Meta Tag Restrictions:** The policy delivered via meta tag is applied as an **additional restriction** using intersection semantics. The meta tag can only make the policy MORE restrictive, never more permissive.

3.  **Intersection Calculation:**
    *   `effective.defaults = header.defaults ∩ meta.defaults`
    *   `effective.constraints = header.constraints ∪ meta.constraints`

**Example (Precedence Resolution):**

```http
WAM-Policy: {"defaults":{"wam-policy-output":["style","content","annotation"]}}
```

```html
<meta name="wam-policy" content='{"defaults":{"wam-policy-output":["style","annotation"]}}'>
```

**Effective Policy:**
```
defaults.wam-policy-output = [style, content, annotation] ∩ [style, annotation]
                           = [style, annotation]
```

The meta tag removed `content` from the allowed outputs, which is permitted. A meta tag attempting to ADD permissions not in the header would have no effect.

### Timing and Blocking

The User Agent MUST resolve the Global Policy before initiating any LLM interaction with the document.

*   **HTTP Header:** Available immediately upon response receipt. Does not block HTML parsing.
*   **External File (via `WAM-Policy-Src` or `wam-policy-src`):** The User Agent MUST fetch and parse the policy file before LLM interaction. This fetch SHOULD be initiated as early as possible (e.g., during HTML preload scanning).
*   **Meta Tag:** Parsed during normal HTML parsing. The User Agent MUST NOT allow LLM interaction with elements that appear before the meta tag until the meta tag is processed.

If the external policy file fails to load (network error, 4xx/5xx response), the User Agent MUST apply **fail-closed** semantics: treat the document as if it had `wam-policy-input="none"` on the root element (no LLM visibility).

### Policy Immutability

Once the Global Policy is resolved (after HTTP headers are received and any external files are fetched), the policy is **immutable** for the lifetime of the document.

*   Page scripts MUST NOT be able to modify the effective Global Policy.
*   Dynamically inserted `<meta name="wam-policy">` tags MUST be ignored.
*   The policy persists across soft navigations (SPA route changes via `pushState`).

For applications requiring per-route policies, the server SHOULD deliver different policies via HTTP header for each route, or the application SHOULD use local DOM attributes (`wam-policy-*`) on route containers.

### Error Handling

If the Global Policy JSON is malformed or fails schema validation:

*   **HTTP Header:** The User Agent MUST apply fail-closed semantics (no LLM visibility) and SHOULD report the error to the developer console.
*   **Meta Tag:** The User Agent MUST ignore the malformed meta tag and continue with the HTTP header policy (if present) or specification defaults.
*   **External File:** The User Agent MUST apply fail-closed semantics if the file is unparseable.

The User Agent SHOULD report policy parsing errors to the `report-to` endpoint if one is configured in a valid portion of the policy.

## JSON Schema

The global policy is defined as a JSON object. This schema enforces site-wide defaults and specific constraints, such as blocking specific selectors or enforcing co-occurrence dependencies (e.g., preventing a quote from appearing without its citation).

```json
{
  "report-to": "https://api.example.com/llm-reports",
  "report-only": true,
  "defaults": {
    "wam-policy-input": ["structure", "text", "attributes", "media"],
    "wam-policy-output": ["readonly"],
    "wam-policy-memory": ["none"]
  },
  "constraints": {
    "block-selectors": ["css-selector", "..."],
    "category-rules": {
      "advertisement": { "wam-policy-input": ["none"] },
      "quote": { "wam-policy-output": ["readonly"] }
    },
    "dependencies": [
      {
        "trigger": ".pull-quote",
        "requires": ".attribution-context",
        "scope": "input",
        "failure-mode": "omit-trigger"
      }
    ]
  }
}
```

### Constraint Types
*   **`block-selectors`:** Forcibly removes elements matching the CSS selector from the LLM's view.
*   **`category-rules`:** Maps an `wam-intent-category` value (e.g., `advertisement`) to specific policy enforcements (e.g., `block`). This allows semantic control over policy without relying on brittle CSS classes.
*   **`dependencies`:** Enforces co-occurrence of elements to maintain context (e.g., requiring a citation for a quote).

### Policy Reporting

The Global Policy Header supports a reporting mechanism to help developers audit compliance and debug policy configurations without breaking functionality.

*   **`report-to` (URI):** Specifies the endpoint where the User Agent SHOULD send violation reports. The reports are sent as JSON payloads containing details about the attempted mutation, the violated policy, and the target element.
*   **`report-only` (Boolean):** If `true`, the User Agent MUST enforce policies in **Audit Mode**. Violations are reported to the `report-to` endpoint, but the mutations themselves are **allowed** to proceed. This is critical for safely rolling out restrictive policies on live sites.

## Precedence and Inheritance

The effective policy for any element is determined by a layered precedence model. At each layer, **intersection semantics** apply: permissions are only granted if ALL applicable layers agree.

### Precedence Layers (Highest to Lowest Authority)

1.  **License Profile:** If `wam-policy-license` specifies an SPDX identifier, the license's implicit constraints take highest precedence. See Section 6.
2.  **Global Policy Constraints:** Constraints from `block-selectors`, `category-rules`, and `dependencies` cannot be overridden by any lower layer.
3.  **Global Policy (HTTP Header):** The policy delivered via HTTP header establishes the authoritative defaults.
4.  **Global Policy (Meta Tag):** Can only restrict (never expand) the HTTP header policy via intersection.
5.  **Shadow DOM Boundary:** If the element is within a shadow tree, inheritance from light DOM requires explicit opt-in. See Section 10.
6.  **Inherited Policy:** Policy inherited from ancestor elements in the DOM tree.
7.  **Local Attributes:** Policy attributes on the element itself (`wam-policy-input`, `wam-policy-output`, `wam-policy-memory`).

### Effective Policy Calculation

For any element, the effective policy is computed as:

```
EffectivePolicy(element) =
    LicenseProfile(element)                    // If wam-policy-license present
  ∩ GlobalConstraints                          // block-selectors, category-rules
  ∩ GlobalDefaults(header ∩ meta)              // Resolved global defaults
  ∩ InheritedPolicy(ancestors)                 // DOM inheritance chain
  ∩ LocalAttributes(element)                   // Element's own attributes
```

### Inheritance Rules

1.  **DOM Inheritance:** Attributes on a node apply to all its descendants unless a descendant specifies its own attribute.
2.  **Shadow Boundary:** Shadow roots block inheritance by default. Components must opt-in via `wam-policy-inherit`.
3.  **Slotted Content:** Subject to intersection of light DOM policy AND slot container policy.
4.  **Constraints Are Absolute:** Global Policy constraints (`block-selectors`, `category-rules`) MUST NOT be overridden by any local attribute or inheritance.

### Conflict Resolution

When computing intersections, the following rules apply:

*   **Token Intersection:** Only tokens present in ALL applicable policies are granted.
*   **Empty Intersection:** If intersection results in an empty set for `wam-policy-output`, the effective policy is `readonly`.
*   **Conflicting Defaults:** If no explicit policy exists at any layer, specification defaults apply (`input=all`, `output=readonly`, `memory=none`).

# Tool Lifecycle Model

This section defines the normative model by which a conforming User Agent mediates all interaction between an LLM and the document. Every LLM action on the document — reading content, applying mutations, invoking controls — MUST occur through a defined **WAM MCP Tool**. The User Agent MUST NOT allow the LLM to observe or modify the document by any other mechanism.

The set of tools offered to the LLM is not fixed: it is computed from the document's WAM attributes and the current Global Policy, and it changes over the course of a page session. This computed tool set is the primary enforcement mechanism for WAM policies. An LLM cannot attempt a disallowed mutation if the corresponding tool is absent from the set of tools offered to it.

### Tool Availability Model

The UA presents the LLM with a fully initialized tool set from the start of every page session. Context discovery (§12.1) is performed by the UA before LLM interaction begins — the LLM does not call a tool to trigger it and requires no initial handshake to unlock mutation or interaction tools.

The active `tools/list` contains:

1.  **Context tools** (§12.2) — global, read-only tools for inspecting elements, querying policies, and checking provenance. These do not require a specific element to be targeted.

2.  **Per-element tools** — mutation tools (§12.3) and interaction tools (§12.4) that take a `selector` argument identifying the target element. Each per-element tool's `selector` parameter MUST be constrained to an enum of the selectors of elements for which that tool is permitted (see §12.3). A tool with no valid targets MUST be omitted from `tools/list` entirely.

If a dynamic DOM modification invalidates the current tool set, the UA MUST re-run context discovery automatically and deliver the refreshed tool set and context to the LLM before accepting further tool calls (see §13.2).

## 11. The Two-Phase Lifecycle

WAM governs two phases of every LLM session. Both are UA-enforced; the LLM's reasoning between them is outside the scope of this specification.

**Phase 1: Initialization** — Before the LLM session begins, the User Agent runs context discovery (§12.1). Policy and intent attributes are fully resolved at this point: the UA produces the filtered HTML fragment, the Mutable Element Manifest (with intent metadata per element), and a fully populated `tools/list` with enum-constrained selectors. The LLM receives all three before making any call. Policy enforcement is structural and complete at this stage — the LLM cannot target what is not in a tool's enum.

**Phase 2: Record** — Each tool call that modifies the document (mutation tools and `wam_invoke`) is executed atomically with a Provenance Ledger write (§9, §13.3). The DOM is not modified until the ledger entry is written. There is no unrecorded LLM-initiated change to the document.

The WAM namespaces map onto these two phases as follows:

| Concern | Namespace | Phase |
| :--- | :--- | :--- |
| Which tools are offered; what content is visible | `wam-policy-*` | Phase 1: Initialization (§12.1) |
| How each element is characterized in the manifest | `wam-intent-*` | Phase 1: Initialization (§12.1) |
| What is written after each tool call | `wam-provenance-*` | Phase 2: Record (§9, §13.3) |

## 12. Tool Taxonomy

WAM MCP tools are divided into four categories based on capability class and gating requirements.

### 12.1. Session Initialization (UA-Internal)

Before initiating LLM interaction with a page, the User Agent MUST perform **context discovery**. This is a UA-internal process — the LLM does not call a tool to trigger it. The UA MUST:

1.  Filter the document's HTML by `wam-policy-input`, producing the **filtered HTML fragment**.
2.  Compose the **system prompt** from `wam-intent-*` attributes across the page (§8).
3.  Build the **Mutable Element Manifest** (§12.6).
4.  Build the initial `tools/list` with enum-constrained selectors (§12.3, §12.4).
5.  Deliver the filtered HTML fragment, composed system prompt, and Mutable Element Manifest to the LLM as part of session setup — for example, in the initial system prompt or a preceding context message — before any tool use occurs.

The LLM therefore begins the session with full context and a fully populated tool set. No initial tool call is required.

If a dynamic DOM modification invalidates the current tool set (§13.2), the UA MUST re-run context discovery automatically, update `tools/list`, and deliver the refreshed context to the LLM before accepting further tool calls.

### 12.2. Context Tools

Context tools are read-only with respect to the document and generate no Provenance Ledger entries. They are available throughout the page session, regardless of element-level policies.

| Tool | Description |
| :--- | :--- |
| `wam_read_element` | Returns the policy-filtered content of a single element, identified by selector. |
| `wam_get_policy` | Returns the computed Effective Permission Set for an element. |
| `wam_list_mutable_elements` | Returns all elements for which at least one mutation tool is currently available. |
| `wam_inspect_provenance` | Returns the Provenance Ledger entries for an element. |
| `wam_report_violation` | Reports an integrity violation observed by the LLM (e.g., unexpected content). The User Agent MUST treat this as equivalent to a UA-detected violation and fire the `llmintegrityviolation` event (§9.9). |

A conforming UA MUST include all five context tools in `tools/list`, regardless of page policy.

### 12.3. Mutation Tools (Policy-Gated)

Mutation tools modify the document. Each is unlocked by a specific `wam-policy-output` token. For each mutation tool, the UA MUST:

1.  Collect the selectors of all elements whose Effective Permission Set includes the corresponding token.
2.  If that set is non-empty, include the tool in `tools/list` with the `selector` parameter's JSON Schema `enum` set to exactly that set of selectors.
3.  If that set is empty, omit the tool from `tools/list` entirely.

This enum-constrained encoding ensures the LLM cannot form a syntactically valid call targeting an element that does not permit the tool.

| Tool | Required Token | Operation |
| :--- | :--- | :--- |
| `wam_apply_style` | `style` | Modifies `class` and `style` attributes. |
| `wam_set_interaction` | `interaction` | Modifies event handlers, ARIA states, and form state attributes. |
| `wam_reorder_children` | `layout` | Permutes the direct child nodes of an element. |
| `wam_annotate` | `annotation` | Wraps text runs in inline elements without altering text content. |
| `wam_set_content` | `content` | Replaces text node content. |
| `wam_set_data` | `data` | Modifies form values, `data-*` attributes, `<meta>` content, and JSON-LD blocks. |
| `wam_insert` | `append` | Inserts new nodes relative to an element, according to a `position` parameter: `"before"` (as a preceding sibling), `"after"` (as a following sibling), `"first-child"` (inside, before existing children), or `"last-child"` (inside, after existing children). The `append` token on the reference element grants all four positions. |
| `wam_set_intent` | `intent` | Sets or updates `wam-intent-category`, `wam-intent-description`, `wam-intent-importance`, and `wam-intent-entity` on the element. |

*Note:* The `mutable` token grants all eight mutation tools simultaneously.

*Note on content sourcing:* `wam_insert` governs the *insertion* of new content into the DOM. WAM takes no position on where that content originates — the LLM may generate it directly or receive it from external tooling outside this specification. A UA MAY provide additional non-WAM tools for fetching external resources (e.g., HTTP requests, search results); such tools are an implementation choice and are out of scope here.

Because the selector enum is per-tool, the same element may appear in the selector enum of some tools but not others within the same `tools/list` response. The Mutable Element Manifest (§12.6) provides the LLM with the same per-element view of available tools for planning purposes.

### 12.4. Interaction Tools (Intent-Gated)

Interaction tools invoke controls on the page. They are gated by `wam-intent-function` or `wam-intent-workflow` rather than by output policy tokens, and additionally require `interaction` (or `mutable`) in the element's effective output policy.

| Tool | Gate condition | Action |
| :--- | :--- | :--- |
| `wam_invoke` | Element has `wam-intent-function` OR `wam-intent-workflow`, AND `interaction` ∈ Effective Permission Set | Invokes the control's primary action or advances a workflow stage. The `action` argument mirrors the `wam-intent-function` value; the `stage` argument mirrors the `wam-intent-workflow` value. Both parameters are present when both attributes are declared. |

The User Agent MUST include `wam_invoke` in `tools/list` if at least one element satisfies both gate conditions, with its `selector` parameter's JSON Schema `enum` set to the selectors of all such elements. If no element satisfies both conditions, `wam_invoke` MUST be omitted from `tools/list` entirely. See §8.1 for the complete parameter rules.

`wam_invoke` calls are subject to the same Record phase atomicity as mutation tools (§13.3). The User Agent MUST write a Provenance Ledger entry for each `wam_invoke` call using layer `interaction` before the invocation is dispatched to the page.

### 12.5. The Mutable Element Manifest

The UA delivers, alongside the filtered HTML fragment and composed system prompt, a **Mutable Element Manifest**: a structured enumeration of every element for which at least one mutation tool is currently available AND which is visible in the filtered HTML fragment.

An element MUST NOT appear in the Mutable Element Manifest if its effective `wam-policy-input` is `none`. The manifest is a subset of the filtered context: every element in the manifest MUST also be present in the filtered HTML fragment. This ensures the LLM can always locate and inspect manifest elements within the context it has been given.

Each manifest entry MUST include:

*   **`selector`**: A UA-assigned CSS selector that uniquely identifies the element within the current document.
*   **`available_tools`**: The list of mutation and interaction tool names available for this element.
*   **`intent`**: The element's resolved intent metadata, comprising `category`, `description`, `importance`, and `entity` if present.
*   **`provenance`**: Any pre-existing provenance metadata on the element: `source`, `citation`, and prior `operations`.

The `wam_id` field (the element's `id` attribute) MUST be included if present.

A conforming UA MUST keep the manifest consistent with the actual offered tool list at all times. A tool MUST NOT appear in the manifest but be absent from `tools/list`, or vice versa.

## 13. Interaction Protocol

### 13.1. UA-Initiated Context Discovery

A conforming UA MUST perform context discovery (§12.1) before initiating LLM interaction with any page or after any navigation. Discovery is a UA-internal process: the LLM receives the filtered HTML fragment, composed system prompt, and Mutable Element Manifest as part of session initialization — not via a tool call.

The UA MUST NOT initiate LLM interaction until context discovery has completed. The LLM's first available `tools/list` MUST already contain the full set of context tools (§12.2), mutation tools (§12.3) with enum-constrained selectors, and interaction tools (§12.4) computed from the page's WAM attributes.

### 13.2. Selector Stability

The UA-assigned selectors in the Mutable Element Manifest and in tool call arguments MUST remain stable for the duration of a single page session. If a dynamic DOM modification invalidates a previously issued selector, the User Agent MUST re-run context discovery automatically (§12.1), update `tools/list` with the refreshed selector enums, and deliver the updated context to the LLM before accepting further mutation tool calls.

### 13.3. Atomicity

Each tool call that modifies the document — mutation tools (§12.3) and `wam_invoke` (§12.4) — MUST be atomic with respect to the Provenance Ledger. The User Agent MUST execute steps in the following order:

1.  Verify the selector resolves to the expected element and that the session has been initialized and not subsequently invalidated (§13.2).
2.  Execute the mutation in memory (do not yet apply to the live DOM).
3.  Write the Provenance Ledger entry (§9.1).
4.  Append the `<layer>:<explanation>` token to the element's `wam-provenance-operation` attribute (§9.1).
5.  Apply the mutation to the live DOM.
6.  Return success to the LLM.

The ledger write (steps 3–4) MUST complete before the DOM is modified (step 5). If either ledger step cannot complete, steps 5 and 6 MUST NOT execute. The live DOM and Provenance Ledger are always consistent.

### 13.4. Prompt Injection Hardening

The User Agent MUST treat all tool arguments as untrusted input.

*   **Selector arguments** MUST be validated as syntactically well-formed CSS selectors that resolve to a node within the current document. This is a defence against prompt-injection attacks that attempt to craft malformed selectors — it is not a policy enforcement check. Policy enforcement is structural: each tool's `selector` enum (§12.3) constrains which elements can be targeted before the call reaches the UA.
*   **Value arguments** for mutation tools MUST be sanitised before DOM application. Executable content — `<script>` elements, `javascript:` URL schemes, and event handler attributes (`on*`) — MUST be stripped from any HTML value.

## 14. Conformance Requirements (Tool Layer)

A **WAM-conforming User Agent** at the tool layer MUST satisfy all of the following:

1.  **UA-initiated discovery:** Run context discovery (§12.1) before initiating LLM interaction with any page or after any navigation. Deliver the filtered HTML fragment, composed system prompt, and Mutable Element Manifest to the LLM as part of session initialization.
2.  **Complete initial tool set:** The LLM's first `tools/list` MUST contain all context tools (§12.2), plus mutation and interaction tools with enum-constrained selectors computed from WAM attributes.
3.  **Enum-constrained mutation selectors:** For each mutation tool, include it in `tools/list` with a `selector` enum listing exactly the selectors of elements whose Effective Permission Set includes the corresponding token. Omit the tool entirely if no such elements exist (§12.3).
4.  **Enum-constrained interaction selectors:** Include `wam_invoke` in `tools/list` with a `selector` enum listing exactly the selectors of elements that satisfy both gate conditions. Omit `wam_invoke` entirely if no such elements exist (§12.4).
5.  **Atomic tool execution:** Apply the Verify → Execute → Record → Commit sequence for every mutation tool call and every `wam_invoke` call. The ledger write MUST precede the DOM modification; if the ledger write cannot complete, the DOM MUST NOT be modified (§13.3).
6.  **Manifest consistency:** The Mutable Element Manifest delivered at session initialization MUST exactly match the offered tool list at all times. Every manifest element MUST also be present in the filtered HTML fragment.
7.  **Visibility prerequisite for mutability:** Never include an element in the Mutable Element Manifest or in any tool's `selector` enum if that element's effective `wam-policy-input` is `none`. An invisible element is undiscoverable and therefore unmutable, regardless of its `wam-policy-output` value.
8.  **Selector syntax validation:** Reject selector arguments that are syntactically invalid or resolve outside the current document (§13.4). This is a defence against prompt injection, not a policy check.

# Processing Model

This section defines the normative requirements for User Agents when enforcing mutation policies. The User Agent MUST calculate the **Effective Permission Set** as the union of all tokens present in the `wam-policy-output` attribute.

## 1. The Semantic Payload Principle (Core Constraint)

Regardless of the permission set, the User Agent MUST determine the mutability of any specific attribute or node based on its semantic role. This principle applies within every mutation tool call: even when a tool is offered and its gate conditions are satisfied, individual attributes and nodes within the target element remain subject to these constraints. Token presence exposes a tool; the Semantic Payload Principle constrains what that tool may touch.

*   **Immutable Payload (Identity & Reference):** Attributes defining identity (`id`, `name`), structure (`for`, `headers`), or data source/destination (`src`, `href`, `action`, `data`) are **strictly readonly** unless the `mutable` token is explicitly present.
*   **Mutable State (Presentation & Interaction):** Attributes defining visual style (`class`, `style`) or transient state (`aria-*`, `checked`, `open`) are subject to specific permission tokens.

## 2. Global Policy Resolution (Category Conflicts)

When multiple `wam-intent-category` values apply to a single node, and the Global Policy defines conflicting rules for these categories, the User Agent MUST resolve the conflict using **Intersection Logic** (Restrictive Priority). Because tokens map directly to tools (§3, §12.3), narrowing the Effective Permission Set through intersection also narrows the offered tool list for that element.

*   **Rule:** The effective permission set granted by the Global Policy is the **intersection** of the allowed tokens for each applicable category.
*   **Implication:** If *any* active category rule forbids a specific action (by omitting the corresponding token), that action is forbidden, even if other categories would allow it. The corresponding mutation tool MUST NOT appear in `tools/list` for that element.
*   **Example:**
    *   Category A (`user-content`) allows: `content`, `interaction`.
    *   Category B (`archived`) allows: `readonly` (empty set).
    *   **Result:** `content` AND `interaction` AND `(empty)` = `readonly`. Neither `wam_set_content` nor `wam_set_interaction` is offered for this element.

## 3. Token-Based Enforcement

Each `wam-policy-output` token serves two normative purposes: it causes the corresponding **WAM MCP mutation tool** to appear in the `tools/list` response for that element (§12.3), and it defines the exact DOM operations that tool is permitted to perform. The User Agent MUST NOT include a mutation tool unless its corresponding token is present in the Effective Permission Set, and MUST NOT permit the tool to perform any operation not listed for its token below.

See §12.3 for the canonical mapping of tokens to tool names.

### `style` (Presentation Layer)

*   **Exposed tool:** `wam_apply_style`
*   **Allowed:** Modification of `class` and `style` attributes.
*   **Blocked:** Everything else.

### `interaction` (Behavioral Layer)

*   **Exposed tool:** `wam_set_interaction`; also gates `wam_invoke` when `wam-intent-function` is present (§12.4).
*   **Allowed:**
    *   Modification of `class`, `style`.
    *   Modification of Event Handlers (`on*`) and ARIA states (`aria-*`).
    *   Modification of global interaction attributes (`tabindex`, `hidden`, `contenteditable`, `draggable`, `spellcheck`).
    *   Insertion of `<script>` and `<style>` elements.
    *   Modification of Form State (`checked`, `selected`, `disabled`, `readonly`, `open`).
*   **Blocked:** Modification of Text Nodes, Payload Attributes (`src`, `href`, `id`), and Data Values (`value`, `data-*`).

### `layout` (Structural Reordering)

*   **Exposed tool:** `wam_reorder_children`
*   **Allowed:** Reordering (permuting) of direct child nodes.
*   **Blocked:** Modification, addition, or removal of child nodes.

### `annotation` (Non-Destructive Wrapping)

*   **Exposed tool:** `wam_annotate`
*   **Allowed:** Splitting text nodes and wrapping them in inline elements (e.g., `<span>`, `<mark>`, `<a>`).
*   **Constraint:** The concatenated `textContent` of the parent element MUST remain identical.
*   **Blocked:** Changing the text characters themselves.

### `content` (Text Layer)

*   **Exposed tool:** `wam_set_content`
*   **Allowed:** Modification of Text Nodes.
*   **Blocked:** Changing the DOM structure or attributes of container elements.

### `data` (Machine-Readable Payload)

*   **Exposed tool:** `wam_set_data`
*   **Allowed:**
    *   **Form Values:** Modification of the `value` attribute on form controls.
    *   **Data Attributes:** Modification of custom `data-*` attributes.
    *   **Meta Content:** Modification of the `content` attribute on `<meta>` tags.
    *   **Data Blocks:** Modification of text content within `<script>` tags that have a data MIME type (e.g., `application/ld+json`, `application/json`) but NOT executable scripts (`text/javascript`).
*   **Blocked:** Modification of Rendered Text Nodes or Document Structure.

### `append` (Additive Structure)

*   **Exposed tool:** `wam_insert`
*   **Allowed:** Insertion of new nodes at any of four positions relative to the element: `"before"` (preceding sibling), `"after"` (following sibling), `"first-child"` (inside, before existing children), `"last-child"` (inside, after existing children).
*   **Blocked:** Modification or removal of existing nodes.

### `intent` (Semantic Metadata)

*   **Exposed tool:** `wam_set_intent`
*   **Allowed:** Setting or updating `wam-intent-category`, `wam-intent-description`, `wam-intent-importance`, and `wam-intent-entity` on the element.
*   **Blocked:** Setting `wam-intent-function` or `wam-intent-workflow`. These are tool availability signals that affect `tools/list` and `wam_invoke` exposure; they are exclusively author-controlled and MUST NOT be writable by the LLM.
*   **Manifest refresh:** After `wam_set_intent` completes, the User Agent MUST update the affected element's entry in the Mutable Element Manifest to reflect the new intent metadata before delivering any further context to the LLM.

### `mutable` (Full Access)

*   **Exposed tools:** All eight mutation tools simultaneously (`wam_apply_style`, `wam_set_interaction`, `wam_reorder_children`, `wam_annotate`, `wam_set_content`, `wam_set_data`, `wam_insert`, `wam_set_intent`).
*   **Allowed:** All operations. The User Agent removes all output-token restrictions for this node.

## 4. Enforcement of Visibility (`wam-policy-input`)

`wam-policy-input` governs the context filtering performed during session initialization (§12.1) and the context tool `wam_read_element` (§12.2). Unlike `wam-policy-output`, visibility tokens do not expose or suppress individual tools. Instead, they control what content is delivered to the LLM: an element's visibility tokens determine which channels (text, attributes, media) appear in the filtered HTML fragment and in tool responses.

**Visibility as a prerequisite for mutability:** An element with `wam-policy-input="none"` is invisible to the LLM — it MUST be omitted from the filtered HTML fragment AND from the Mutable Element Manifest (§12.5). The LLM cannot discover the element's existence and therefore cannot target it with mutation or interaction tools. This holds regardless of the element's `wam-policy-output` value: an element that is invisible cannot be mutable, because mutability requires that the LLM be able to identify and address the element. `wam-policy-output` tokens on an invisible element are inert — they do not cause tools to appear in `tools/list`.

For elements with partial visibility (`wam-policy-input="structure"`, `"structure text"`, etc.), the element is visible in the filtered context and MAY appear in the Mutable Element Manifest if its output policy permits.

The User Agent MUST transform the DOM into a context representation for the LLM by filtering nodes based on the `wam-policy-input` tokens. This section defines the normative requirements for context construction.

### 4.1. Context Representation Format

The context representation is the filtered HTML fragment delivered at session initialization and the content returned by `wam_read_element`. It MUST be an HTML fragment string. The User Agent MAY support additional output formats (plain text, Markdown, accessibility tree) as implementation-defined options, but HTML is the normative default.

**Output Requirements:**

1.  **Well-formed HTML:** The output MUST be a well-formed HTML fragment that could be parsed by a standard HTML parser.
2.  **Encoding:** The output MUST be encoded as UTF-8.
3.  **No Wrapper:** The output MUST NOT include `<!DOCTYPE>`, `<html>`, `<head>`, or `<body>` wrapper elements unless they are part of the filtered content itself.

### 4.2. Visibility Token Processing

The effective visibility for a node is the union of all tokens present in its `wam-policy-input` attribute (after inheritance and constraint resolution). The User Agent MUST process each node according to the following rules:

#### `none` (Omission)
If the effective token set is empty or contains only `none`, the User Agent MUST omit the node and all its descendants from the context representation. The node appears as if it does not exist in the document.

#### `structure` (Element Skeleton)
If `structure` is present:
*   The element's opening and closing tags MUST be preserved.
*   The element's position in the document hierarchy MUST be preserved.
*   Child elements MUST be processed recursively according to their own visibility rules.

If `structure` is present but `text` is NOT:
*   All text node descendants MUST be replaced with the placeholder string `[REDACTED]`.
*   Multiple consecutive text nodes MAY be collapsed into a single placeholder.

#### `text` (Text Content)
If `text` is present:
*   Text nodes MUST be preserved with their content intact.
*   The text content MUST reflect the current DOM state (including any script-driven modifications).

#### `attributes` (Element Attributes)
If `attributes` is present:
*   All attributes on the element MUST be preserved, except as restricted by the Semantic Payload Principle or security filtering (see Section 4.5).

If `structure` is present but `attributes` is NOT:
*   The User Agent MUST strip all attributes except:
    *   `id` (for structural reference)
    *   `class` (for semantic classification)
    *   `role` (for accessibility semantics)
    *   All `llm-*` attributes (for policy and intent metadata)
    *   All `aria-*` attributes (for accessibility state)

#### `media` (Media Content)
If `media` is present:
*   Media-specific attributes MUST be preserved on media elements:
    *   `<img>`: `src`, `srcset`, `alt`, `width`, `height`
    *   `<video>`: `src`, `poster`, `width`, `height`
    *   `<audio>`: `src`
    *   `<source>`: `src`, `srcset`, `type`, `media`
    *   `<picture>`: All child `<source>` elements processed recursively

If `structure` is present but `media` is NOT:
*   Media-specific attributes MUST be replaced with placeholders:
    *   `<img>`: Replace `src` with empty string, set `alt="[image]"` if `alt` was present or add `alt="[image]"` if absent
    *   `<video>`: Replace `src` and `poster` with empty strings, content replaced with `[video content]`
    *   `<audio>`: Replace `src` with empty string, content replaced with `[audio content]`
    *   `<canvas>`: Content replaced with `[canvas graphic]`

#### `all` (Full Visibility)
The token `all` is equivalent to `structure text attributes media`. All content is preserved without redaction.

### 4.3. Whitespace Normalization

The User Agent MUST normalize whitespace in the context representation according to the following rules:

1.  **Collapse Whitespace:** Sequences of whitespace characters (space, tab, newline, carriage return) MUST be collapsed to a single space character, except as noted below.

2.  **Trim Element Boundaries:** Leading whitespace after an opening tag and trailing whitespace before a closing tag MAY be removed for non-inline elements.

3.  **Preserve Preformatted Content:** Whitespace MUST be preserved exactly within:
    *   `<pre>` elements and their descendants
    *   `<code>` elements (unless nested in a context that normalizes)
    *   `<textarea>` element content
    *   Elements with `style="white-space: pre"` or equivalent (if `attributes` token includes style)
    *   Elements with `xml:space="preserve"`

4.  **Script and Style Content:** Whitespace within `<script>` and `<style>` elements MUST be preserved exactly to maintain code validity.

### 4.4. Special Element Handling

The following elements require special processing:

#### Script Elements
`<script>` elements MUST be included in the context representation if their ancestor visibility allows. Scripts are essential for understanding page behavior when the `interaction` output token permits script insertion or modification.

*   **Executable Scripts** (`type="text/javascript"` or no `type`): Include the element and its content.
*   **Data Scripts** (`type="application/json"`, `type="application/ld+json"`, etc.): Include the element and its content. These may be modified via the `data` output token.
*   **Module Scripts** (`type="module"`): Include the element and its content.

#### Style Elements
`<style>` elements MUST be included in the context representation if their ancestor visibility allows. Styles are essential for understanding page presentation when the `style` or `interaction` output tokens permit style modification or insertion.

#### Template Elements
`<template>` elements are inert and MUST be included with their content if visibility allows. The template content represents potential DOM that may be instantiated.

#### Comment Nodes
HTML comments MUST be stripped from the context representation. Comments are not part of the rendered document and may contain implementation notes not intended for LLM consumption.

#### Iframe Elements
`<iframe>` elements MUST be represented as empty placeholder elements: `<iframe src="[cross-origin content]"></iframe>`. The User Agent MUST NOT include cross-origin iframe content in the context representation due to security boundaries.

### 4.5. Security Filtering

Regardless of visibility tokens, the User Agent MUST apply security filtering:

1.  **Event Handler Attributes:** Attributes beginning with `on` (e.g., `onclick`, `onload`) MUST be stripped from the context representation. The LLM can observe that interactive behavior exists via the `interaction` output token, but raw handler code poses injection risks if echoed back.

2.  **JavaScript URLs:** Attribute values beginning with `javascript:` MUST be replaced with `[javascript]`.

3.  **Data URLs:** Large `data:` URLs (exceeding 1024 characters) MAY be truncated with a placeholder indicating the MIME type: `data:image/png;[truncated]`.

### 4.6. Placeholder Format

When content is redacted or replaced, the following placeholder formats MUST be used:

| Context | Placeholder |
|---------|-------------|
| Text content (structure without text) | `[REDACTED]` |
| Image without media token | `alt="[image]"` |
| Video without media token | `[video content]` |
| Audio without media token | `[audio content]` |
| Canvas element | `[canvas graphic]` |
| Cross-origin iframe | `[cross-origin content]` |
| Truncated data URL | `data:<mime>;[truncated]` |
| JavaScript URL | `[javascript]` |

### 4.7. Importance-Based Prioritization

When constructing context for token-limited LLM interactions, the User Agent SHOULD prioritize content based on `wam-intent-importance`:

1.  **`critical`:** MUST be included. If token limits prevent inclusion, the User Agent MUST report an error rather than omit critical content.
2.  **`high`:** SHOULD be included before `normal` content.
3.  **`normal`:** Default prioritization.
4.  **`low`:** MAY be truncated if token limits require.
5.  **`background`:** SHOULD be truncated first if token limits require.

The specific algorithm for token budgeting and truncation is implementation-defined. When truncation occurs, the User Agent SHOULD append `<!-- [content truncated] -->` to indicate incomplete context.

### 4.8. Default Behavior

If no `wam-policy-input` attribute is present on a node and no inherited or global policy applies, the default visibility is `all` (equivalent to `structure text attributes media`), providing full visibility to the LLM.

## 5. Enforcement of Retention (`wam-policy-memory`)

`wam-policy-memory` governs the **Record phase** (§11) across all WAM MCP tool calls: it constrains what any tool may retain after execution completes. The retention rules apply to the full content a tool observes, not only to the mutation it produces.

The User Agent MUST signal and enforce storage limitations based on the `wam-policy-memory` tokens.

*   **`none` (Ephemeral):**
    *   **Signal:** The User Agent MUST send a standard HTTP header (e.g., `Cache-Control: no-store`) or an equivalent signal to the LLM service indicating that the context is ephemeral.
    *   **Storage:** The User Agent MUST NOT persist the interaction content in any persistent storage (e.g., `localStorage`, `IndexedDB`) beyond the lifespan of the request/response cycle.
*   **`session` (Context Window):**
    *   **Signal:** Allows session-scoped context.
    *   **Storage:** The User Agent MAY store the interaction in `sessionStorage` or equivalent ephemeral memory until the browser tab or session is closed.
*   **`user` (Profile):**
    *   **Signal:** Allows long-term user profile updates.
    *   **Storage:** The User Agent MAY persist specific facts or preferences derived from the interaction into the user's long-term profile storage (e.g., `localStorage`, synced settings).
*   **`training` (Model Improvement):**
    *   **Signal:** Explicitly authorizes the use of the interaction data for training or fine-tuning the underlying model.
    *   **Default:** Without this token, the User Agent MUST signal `Do-Not-Train` or equivalent.

**Privacy Default:** If no attribute is present, the default is `none` (Strictly Ephemeral).

## 6. Enforcement of Licensing (`wam-policy-license`)

`wam-policy-license` acts as a ceiling on the Effective Permission Set established by `wam-policy-output`. Because each output token corresponds directly to an exposed mutation tool (§12.2, §3), license restrictions are tool restrictions: reducing the effective token set reduces the offered tool list. The User Agent MUST compute the license-intersected Effective Permission Set **before** populating the `tools/list` response and the Mutable Element Manifest (§12.5), so that tools disallowed by license never appear to the LLM.

The User Agent MUST resolve `wam-policy-license` attributes by expanding the license identifier into a set of implicit policy constraints (a **License Profile**). The effective policy for the node is the **intersection** of the explicitly declared `wam-policy-output` tokens and the License Profile's allowed permissions.

### 6.1. License Profile Structure

A License Profile is a data structure containing the following fields:

| Field | Type | Description |
|-------|------|-------------|
| `spdxIdentifier` | String | The canonical SPDX identifier |
| `allowedOutputTokens` | Sequence&lt;String&gt; | Output tokens permitted by this license |
| `requiresAttribution` | Boolean | Whether the license requires attribution |
| `isCopyleft` | Boolean | Whether the license has copyleft/viral requirements |
| `licenseName` | String? | Human-readable name of the license |
| `commercialUse` | Boolean | Whether commercial use is permitted |
| `shareAlike` | Boolean | Whether derivatives must use the same license |

### 6.2. License Compatibility Matrix (Normative)

The User Agent MUST support the following SPDX identifiers with their associated profiles. This matrix defines the **normative** behavior for license enforcement.

#### 6.2.1. Public Domain and Permissive Licenses

These licenses impose minimal or no restrictions on LLM modifications.

| SPDX Identifier | Allowed Tokens | Attribution | Copyleft | Commercial |
|-----------------|----------------|-------------|----------|------------|
| `CC0-1.0` | `mutable` | No | No | Yes |
| `Unlicense` | `mutable` | No | No | Yes |
| `WTFPL` | `mutable` | No | No | Yes |
| `MIT` | `mutable` | Yes | No | Yes |
| `MIT-0` | `mutable` | No | No | Yes |
| `ISC` | `mutable` | Yes | No | Yes |
| `BSD-2-Clause` | `mutable` | Yes | No | Yes |
| `BSD-3-Clause` | `mutable` | Yes | No | Yes |
| `Apache-2.0` | `mutable` | Yes | No | Yes |
| `Zlib` | `mutable` | Yes | No | Yes |

#### 6.2.2. Creative Commons Licenses

Creative Commons licenses have specific conditions that map to output token restrictions.

| SPDX Identifier | Allowed Tokens | Attribution | Copyleft | Commercial | Notes |
|-----------------|----------------|-------------|----------|------------|-------|
| `CC-BY-4.0` | `mutable` | Yes | No | Yes | Derivatives allowed |
| `CC-BY-3.0` | `mutable` | Yes | No | Yes | Legacy version |
| `CC-BY-SA-4.0` | `mutable` | Yes | Yes | Yes | ShareAlike requirement |
| `CC-BY-SA-3.0` | `mutable` | Yes | Yes | Yes | Legacy ShareAlike |
| `CC-BY-NC-4.0` | `mutable` | Yes | No | No | Non-commercial only |
| `CC-BY-NC-3.0` | `mutable` | Yes | No | No | Legacy NC |
| `CC-BY-NC-SA-4.0` | `mutable` | Yes | Yes | No | NC + ShareAlike |
| `CC-BY-ND-4.0` | `readonly`, `annotation` | Yes | No | Yes | **No derivatives** |
| `CC-BY-ND-3.0` | `readonly`, `annotation` | Yes | No | Yes | Legacy ND |
| `CC-BY-NC-ND-4.0` | `readonly`, `annotation` | Yes | No | No | NC + ND |
| `CC-BY-NC-ND-3.0` | `readonly`, `annotation` | Yes | No | No | Legacy NC-ND |

**No Derivatives (ND) Constraint:** For ND licenses, the User Agent MUST restrict output tokens to `readonly` and `annotation` only. The `annotation` token is permitted because it wraps content without modifying the underlying text.

#### 6.2.3. Copyleft Licenses

Copyleft licenses allow modifications but require derivatives to carry compatible licenses.

| SPDX Identifier | Allowed Tokens | Attribution | Copyleft | Commercial | Notes |
|-----------------|----------------|-------------|----------|------------|-------|
| `GPL-2.0-only` | `mutable` | Yes | Yes | Yes | Strong copyleft |
| `GPL-2.0-or-later` | `mutable` | Yes | Yes | Yes | GPL 2+ |
| `GPL-3.0-only` | `mutable` | Yes | Yes | Yes | Strong copyleft |
| `GPL-3.0-or-later` | `mutable` | Yes | Yes | Yes | GPL 3+ |
| `LGPL-2.1-only` | `mutable` | Yes | Yes | Yes | Weak copyleft |
| `LGPL-2.1-or-later` | `mutable` | Yes | Yes | Yes | LGPL 2.1+ |
| `LGPL-3.0-only` | `mutable` | Yes | Yes | Yes | Weak copyleft |
| `LGPL-3.0-or-later` | `mutable` | Yes | Yes | Yes | LGPL 3+ |
| `AGPL-3.0-only` | `mutable` | Yes | Yes | Yes | Network copyleft |
| `AGPL-3.0-or-later` | `mutable` | Yes | Yes | Yes | AGPL 3+ |
| `MPL-2.0` | `mutable` | Yes | Yes | Yes | File-level copyleft |
| `EPL-2.0` | `mutable` | Yes | Yes | Yes | Eclipse copyleft |
| `EUPL-1.2` | `mutable` | Yes | Yes | Yes | EU copyleft |

**Copyleft Constraint:** When `isCopyleft` is true, the User Agent MUST ensure that any LLM-generated content derived from this node is marked with a compatible license in `wam-provenance-operation` entries. The User Agent MAY prevent insertion of copyleft content into contexts marked as proprietary or incompatibly licensed.

#### 6.2.4. Proprietary and Restricted Licenses

These identifiers indicate content that MUST NOT be modified or may have special restrictions.

| SPDX Identifier | Allowed Tokens | Attribution | Copyleft | Commercial | Notes |
|-----------------|----------------|-------------|----------|------------|-------|
| `proprietary` | `readonly` | N/A | N/A | N/A | No modifications |
| `all-rights-reserved` | `readonly` | N/A | N/A | N/A | Traditional copyright |
| `LicenseRef-*` | (varies) | (varies) | (varies) | (varies) | Custom license reference |

**Proprietary Content:** Content marked with `proprietary` or `all-rights-reserved` MUST be treated as `readonly` only. The User Agent MUST NOT permit any output tokens beyond `readonly`.

### 6.3. License Expression Syntax

The User Agent MUST support SPDX License Expression syntax for compound licenses:

*   **`AND` (Conjunction):** Both licenses apply. The effective profile is the **intersection** of allowed tokens from both licenses.
    *   Example: `MIT AND CC-BY-4.0` → `mutable` (both allow), `requiresAttribution: true` (either requires)
*   **`OR` (Disjunction):** Either license may apply. The effective profile is the **union** of allowed tokens from both licenses.
    *   Example: `GPL-3.0-only OR MIT` → `mutable`, User Agent MAY choose the less restrictive option.
*   **`WITH` (Exception):** Adds an exception to a license. The User Agent SHOULD resolve known exceptions.
    *   Example: `GPL-2.0-only WITH Classpath-exception-2.0`

**Parentheses:** The User Agent MUST support parentheses for grouping: `(MIT OR Apache-2.0) AND CC-BY-4.0`.

### 6.4. Unknown License Handling

When the User Agent encounters an SPDX identifier not in its supported list:

1.  **Conservative Default:** The User Agent MUST treat unknown licenses as `readonly` only (most restrictive).
2.  **Attribution Assumed:** The User Agent MUST assume `requiresAttribution: true`.
3.  **Warning:** The User Agent SHOULD emit a warning indicating the license is unrecognized.
4.  **Fallback Override:** Authors MAY provide explicit `wam-policy-output` tokens, but the conservative default still applies via intersection.

### 6.5. Attribution Enforcement

When a License Profile has `requiresAttribution: true`:

1.  **Provenance Citation Required:** Any LLM mutation on this node MUST include a `wam-provenance-citation` attribute or entry linking to the original source.
2.  **Inherited Requirement:** If a child element is modified, the attribution requirement propagates from the licensed ancestor.
3.  **Validation:** The User Agent MUST validate that mutations include proper attribution; violations SHOULD be reported.

### 6.6. Commercial Use Restrictions

When a License Profile has `commercialUse: false` (e.g., CC-BY-NC variants):

1.  **Context Signal:** The User Agent MUST signal to the LLM that this content is non-commercial only.
2.  **Output Restriction:** The User Agent SHOULD prevent insertion of NC-licensed content into contexts identified as commercial.
3.  **Implementation Note:** Detection of "commercial context" is implementation-defined but MAY include signals from the embedding page or user configuration.

### 6.7. Conflict Resolution

If an explicit `wam-policy-output` attribute conflicts with the License Profile:

1.  **License Takes Precedence:** The effective output tokens are the **intersection** of the explicit tokens and the License Profile's allowed tokens.
2.  **Example:** `wam-policy-output="mutable"` with `wam-policy-license="CC-BY-ND-4.0"` results in effective tokens of `readonly`, `annotation` (the ND license restricts to these).
3.  **Warning:** The User Agent MAY emit a warning when an explicit attribute is overridden by license constraints.
4.  **No Expansion:** An explicit attribute cannot grant permissions beyond what the license allows.

### 6.8. License Inheritance

License constraints inherit to descendants unless overridden:

1.  **Downward Propagation:** A `wam-policy-license` attribute applies to all descendants of the element.
2.  **Local Override:** A descendant MAY specify a different `wam-policy-license`, which applies to that subtree.
3.  **Restriction Only:** A descendant's license can only further restrict, not expand, permissions (intersection with ancestor license).
4.  **Mixed Content:** When content from multiple license sources is combined, the most restrictive license applies to the combined output.

## 7. Dependency Resolution (Global Policy)

When constructing the LLM context, the User Agent MUST enforce dependency constraints defined in the Global Policy Header.

1.  **Dependency Graph Construction:** The User Agent identifies all nodes selected for inclusion in the context (Candidate Set).
2.  **Constraint Check:** For each node in the Candidate Set, the User Agent checks if it matches any `trigger` selector defined in the Global Policy's `dependencies` list.
3.  **Requirement Verification:**
    *   If a node matches a `trigger`, the User Agent MUST verify that at least one node matching the `requires` selector is also present in the Candidate Set.
4.  **Failure Resolution:**
    *   If the Requirement Verification fails, the User Agent applies the `failure-mode`:
        *   **`omit-trigger` (Default):** The triggering node is **removed** from the Candidate Set. The User Agent then re-evaluates dependency constraints recursively.
        *   **`error`:** The context construction process is halted, and the User Agent reports a dependency violation error.

## 8. Intent Attribute Processing (Initialization Phase)

This section defines how the User Agent translates `wam-intent` attributes into MCP tool exposure and Mutable Element Manifest content. Intent attributes are fully resolved during **Phase 1: Initialization** of the Tool Lifecycle Model (§11) and have two processing roles: tool availability signals that gate `wam_invoke` exposure, and manifest metadata that the LLM reads during session initialization.

### 8.1. wam_invoke Gating Rules

The `wam_invoke` tool MUST be included in `tools/list` for an element if and only if at least one of `wam-intent-function` or `wam-intent-workflow` is present and the element's effective output policy permits `interaction` (§3).

**Function gating (`wam-intent-function`):**

*   The User Agent MUST expose `wam_invoke` with an `action` parameter.
*   If the attribute value is in the Standardized Lexicon, the `action` parameter description MUST include the Optimized System Prompt for that action.
*   If multiple space-separated values are present, the `action` parameter MUST be an enum containing all values.
*   Custom values produce an unrestricted `action` parameter with the fallback template: `"Use this control to [value]."`

**Workflow gating (`wam-intent-workflow`):**

*   The User Agent MUST expose `wam_invoke` with a `stage` parameter.
*   The `stage` parameter description MUST include the workflow role: `"(Workflow Stage: [value])"`.
*   If both `wam-intent-function` and `wam-intent-workflow` are present, `wam_invoke` MUST accept both `action` and `stage` parameters.

**Interaction policy constraint:** If the element's effective output policy does not include `interaction`, the User Agent MUST NOT expose `wam_invoke`, regardless of the presence of intent attributes. This takes precedence over all gating rules.

### 8.2. Manifest Integration (description, importance, and entity)

The `wam-intent-description`, `wam-intent-importance`, and `wam-intent-entity` attributes are processed during session initialization and populate the Mutable Element Manifest directly.

**Description — prose context:**

If `wam-intent-description` is present, the User Agent MUST populate the `intent.description` field of the element's manifest entry with the attribute value verbatim. The UA MUST NOT interpret, transform, or summarise the value.

**Importance — token-budget ordering:**

The User Agent MUST order elements in the Mutable Element Manifest by importance level, with the following hierarchy (highest priority first):

1.  `critical` — MUST be included even if token limits are reached; MAY truncate element content but MUST NOT omit the entry.
2.  `high` — SHOULD be included before `normal` entries.
3.  `normal` (default) — included in standard ordering.
4.  `low` — included if token budget permits; MAY be omitted.
5.  `background` — included only if token budget is unconstrained; MUST be omitted first when truncating.

When elements are omitted due to token limits, the User Agent MUST include a truncation notice in the manifest indicating how many elements were omitted and at which importance levels.

The `importance` level also maps to hint text appended to the element's manifest entry for the orchestrating LLM:

*   **`critical`:** `"Pay maximum attention to this element. It is essential for the user's task."`
*   **`high`:** `"Prioritize this element."`
*   **`normal`:** (No hint appended.)
*   **`low`:** `"This element is supplementary. You may skip it if context is limited."`
*   **`background`:** `"This is background information only. Do not focus on it unless explicitly asked."`

**Entity — manifest enrichment:**

If `wam-intent-entity` is present, the User Agent MUST populate the `intent.entity` field of the element's manifest entry with the URI value. This canonical entity reference allows the orchestrating LLM to reason about entity identity and to de-duplicate or correlate content across elements before deciding which mutation tool to invoke.

## 9. Provenance Processing Model (Record Phase)

The Record phase (§11) executes as part of the atomicity sequence defined in §13.3: after the in-memory execution of a mutation tool or `wam_invoke` call succeeds, but **before** the change is applied to the live DOM. The User Agent functions as the **Authority** on provenance: it writes the Provenance Ledger entry and updates the DOM's `wam-provenance-operation` attribute before committing the change. Authors and page scripts MUST NOT be able to suppress, reorder, or forge this sequence. This section defines the normative requirements for executing the Record phase, maintaining ledger integrity, and surfacing provenance data through MCP tools and the user interface.

### 9.1. Record Phase Execution Sequence

The Record phase is steps 3–4 of the full atomicity sequence defined in §13.3. It MUST execute after the in-memory execution of the mutation (§13.3 step 2) and before applying the mutation to the live DOM (§13.3 step 5). The User Agent MUST execute the following steps in order:

1.  **Determine layer token:** Map the completed operation to its layer token using the Layer Token Mapping table below.
2.  **Determine explanation:** Use the `explanation` field from the tool call if provided; otherwise construct a default from the operation type and element role.
3.  **Write Provenance Ledger entry:** Create a new ledger entry (schema §9.2) and append it to the internal Provenance Ledger. This is §13.3 step 3.
4.  **Append to DOM attribute:** Append `<layer>:<explanation>` to the target element's `wam-provenance-operation` attribute, space-separated from any existing tokens. This is §13.3 step 4.

Steps 3 and 4 MUST complete before step 5 (the live DOM apply) may proceed. The ledger write and DOM application are atomic: either both occur or neither does. This guarantees the live DOM and Provenance Ledger are always consistent.

*   **Format:** The appended token MUST follow the syntax `<layer>:<explanation>`.
*   **Layer Alignment:** The `<layer>` token MUST match the type of mutation performed (e.g., `content` for text changes, `style` for class changes).
*   **Explanation:** The `<explanation>` SHOULD be a concise, hyphenated rationale generated by the Agent (e.g., `summarized-text`, `corrected-fact`).

#### Layer Token Mapping

| Mutation Type | Layer Token | Examples |
|--------------|-------------|----------|
| Text node content | `content` | Rewriting text, summarizing, correcting |
| `class` or `style` attribute | `style` | Adding highlight class, changing colors |
| Event handlers, ARIA, form state | `interaction` | Adding onclick, changing aria-expanded |
| Child node reordering | `topology` | Sorting list items, reordering sections |
| `data-*` attributes, form values | `data` | Updating data attributes, form autofill |
| `wam-intent-*` attributes (via `wam_set_intent`) | `intent` | Setting or updating semantic metadata |

#### Explanation Format

The explanation component MUST be a hyphenated string of lowercase ASCII letters and numbers. It SHOULD describe the rationale for the change, not the change itself.

**Valid examples:** `summarized-text`, `corrected-spelling`, `user-requested`, `auto-translated`, `fact-checked-false`

**Invalid examples:** `changed the text`, `MODIFIED`, `update_1`

### 9.2. Provenance Ledger Structure

The User Agent MUST maintain an internal **Provenance Ledger** that records all LLM-initiated mutations. This ledger is separate from (but correlated with) the `wam-provenance-operation` attribute. It is the authoritative record and the primary data source for `wam_inspect_provenance`.

#### Ledger Entry Structure

Each ledger entry MUST contain:

| Field | Type | Description |
|-------|------|-------------|
| `id` | String | Unique identifier for this entry |
| `timestamp` | DOMHighResTimeStamp | When the mutation occurred |
| `target` | Element reference | The element that was modified |
| `layer` | LLMProvenanceLayer | The type of mutation |
| `explanation` | String | The hyphenated rationale |
| `originalValue` | Any | Snapshot of the value before mutation |
| `newValue` | Any | The value after mutation |
| `hasAttributeEntry` | Boolean | Whether a corresponding `wam-provenance-operation` entry exists |
| `orchestratingModelId` | String | Identifier of the LLM that issued the mutation tool call |
| `generatingModelId` | String? | Identifier of the model that produced the mutation value, when this differs from the orchestrating model (e.g., when the UA delegated content generation to an external service). Omitted when the orchestrating model provided the value directly. |

**Dual Model ID Requirement:** When `generatingModelId` is populated, it MUST identify the model whose output became the new value. Both `orchestratingModelId` and `generatingModelId` MUST be populated whenever the generating model differs from the orchestrating model.

#### Original Value Snapshots

The `originalValue` field MUST capture sufficient information to reconstruct the pre-mutation state:

| Layer | Original Value Content |
|-------|----------------------|
| `content` | The text content string before modification |
| `style` | Object with `class` and `style` attribute values |
| `interaction` | Object with relevant attribute values (`aria-*`, `on*`, form state) |
| `topology` | Ordered array of child node references or identifiers |
| `data` | Object with `data-*` attribute values and form `value` |
| `intent` | Object with `wam-intent-*` attribute values |

### 9.3. Baseline Snapshot

The User Agent MUST capture a **Baseline Snapshot** of the DOM at a defined point in time. This baseline serves as the reference for detecting unauthorized mutations.

#### Snapshot Timing

The baseline snapshot MUST be captured:

1.  **Initial Load:** After the document has finished parsing (`DOMContentLoaded`) and the Global Policy has been resolved.
2.  **After Server Updates:** After any server-initiated DOM update (e.g., via `innerHTML` assignment from fetch response, server-sent events, WebSocket messages) that is explicitly marked as authoritative.

The User Agent MUST NOT capture a new baseline after LLM-initiated mutations; those are tracked as deltas from the existing baseline.

#### Snapshot Content

For each element in the document, the baseline snapshot MUST record:

*   **Text Content:** The `textContent` of all text nodes.
*   **Attributes:** All attribute name-value pairs.
*   **Child Order:** The ordered list of child element identifiers.
*   **Tree Position:** The element's position in the DOM tree.

The snapshot MAY be stored as a serialized representation, a hash-based diff structure, or a copy-on-write mechanism—the specific implementation is User Agent-defined.

#### Snapshot Scope

The baseline snapshot MUST cover:

*   All elements in the light DOM.
*   Shadow DOM content for shadow roots with `wam-provenance-transparent` (see Section 10.7).
*   Aggregated mutation tracking for other shadow roots.

### 9.4. Mutation Detection

The User Agent MUST detect DOM mutations that could indicate LLM-initiated changes. The detection mechanism MUST NOT rely solely on the LLM reporting its changes; the User Agent independently verifies.

#### Detection Mechanism

The User Agent SHOULD use MutationObserver or an equivalent mechanism to observe:

*   `childList` mutations (node insertion, removal, reordering)
*   `characterData` mutations (text content changes)
*   `attributes` mutations (attribute changes)
*   `subtree` for recursive observation

#### Attribution

When a mutation is detected, the User Agent MUST determine whether it was:

1.  **LLM-Initiated:** The mutation occurred as a result of LLM agent action. These MUST be logged to the ledger.
2.  **User-Initiated:** The mutation occurred as a result of direct user action (typing, clicking). These SHOULD NOT be logged to the LLM provenance ledger.
3.  **Script-Initiated:** The mutation occurred from page JavaScript not related to LLM. These SHOULD NOT be logged to the LLM provenance ledger.

The User Agent MAY use call stack inspection, explicit API markers, or isolated execution contexts to attribute mutations.

### 9.5. Integrity Validation

The User Agent MUST periodically validate that the Provenance Ledger accurately reflects all LLM-initiated mutations.

#### Validation Triggers

Integrity validation MUST occur:

1.  **On Mutation:** After each LLM-initiated mutation is recorded.
2.  **On Read:** Before returning provenance information via `wamProvenance` or `wamProvenanceLedger` APIs.
3.  **Periodically:** At User Agent-defined intervals during active LLM sessions.
4.  **On Navigation:** Before the document is unloaded or navigated away.

#### Validation Algorithm

For each element with LLM-initiated modifications:

1.  **Compare Current State:** Compare the element's current state to its baseline snapshot.
2.  **Identify Layers:** Determine which layers have been modified (content, style, interaction, topology, data, intent).
3.  **Check Ledger:** For each modified layer, verify that a corresponding ledger entry exists.
4.  **Check Attribute:** For each ledger entry, verify that a corresponding `wam-provenance-operation` token exists on the element.
5.  **Flag Violations:** Any mismatch constitutes an integrity violation.

#### Integrity Violation Types

| Violation Type | Description |
|----------------|-------------|
| `missing-ledger-entry` | DOM was modified but no ledger entry exists |
| `missing-attribute-entry` | Ledger entry exists but `wam-provenance-operation` lacks corresponding token |
| `layer-mismatch` | Ledger entry layer does not match the type of detected mutation |
| `orphaned-entry` | Ledger entry exists but no corresponding DOM change detected |
| `tampered-attribute` | `wam-provenance-operation` attribute was modified without corresponding ledger entry |

### 9.6. Violation Response

When an integrity violation is detected, the User Agent MUST respond according to the violation severity and user preferences.

#### Response Actions

The User Agent MAY implement any combination of:

1.  **Flag:** Mark the element with a visual indicator (e.g., colored border, icon) to alert the user.
2.  **Warn:** Display a non-blocking warning in the UI or console.
3.  **Block:** Prevent the modified content from being rendered until user acknowledgment.
4.  **Revert:** Restore the element to its baseline state.
5. **Report:** Send a violation report to the Global Policy's `report-to` endpoint.

#### Revert Algorithm

If the User Agent implements reversion:

1.  Retrieve the `originalValue` from the ledger entry (if available) or baseline snapshot.
2.  Apply the original value to the element:
    *   For `content`: Set `textContent` to original.
    *   For `style`: Restore `class` and `style` attributes.
    *   For `topology`: Reorder children to original sequence.
    *   For `data`: Restore `data-*` attributes and form values.
    *   For `interaction`: Restore event handlers and ARIA states.
3.  Remove the invalid ledger entry.
4.  Update `wam-provenance-operation` attribute to remove the invalid token.
5.  Fire an `llmintegrityviolation` event with `reverted: true`.

#### User Preferences

The User Agent SHOULD allow users to configure violation response behavior:

*   **Strict Mode:** Block or revert all violations automatically.
*   **Permissive Mode:** Flag and warn only; allow content to render.
*   **Report-Only Mode:** Log violations but take no visible action (for debugging).

### 9.7. Ledger Lifecycle

#### Persistence

The Provenance Ledger MUST persist for the lifetime of the document. The ledger MUST NOT be persisted across page loads unless explicitly authorized by `wam-policy-memory="session"` or `wam-policy-memory="user"`.

If memory retention is authorized:

*   **`session`:** The ledger MAY be serialized to `sessionStorage` and restored on back/forward navigation.
*   **`user`:** The ledger MAY be persisted to long-term storage for audit purposes.

#### Memory Management

For long-running pages with many mutations, the User Agent MAY implement ledger compaction:

1.  **Merge Entries:** Multiple mutations to the same element and layer MAY be merged, preserving only the original `originalValue` and the final `newValue`.
2.  **Prune Reverted:** Entries for reverted mutations MAY be removed.
3.  **Archive Old:** Entries older than a User Agent-defined threshold MAY be archived to compressed storage.

The User Agent MUST NOT discard entries that have not been validated or that represent unacknowledged violations.

### 9.8. Mandatory User Inspection

To ensure conspicuous disclosure without cluttering the UI, the User Agent MUST provide a mechanism for the user to inspect the raw provenance data for any element.

#### MCP Interface

The `wam_inspect_provenance` tool (§12.2) is the normative programmatic interface to the Provenance Ledger. It returns the same information that the user-facing inspection UI must display. A conforming UA MUST ensure that the MCP tool and the UI surface identical data: if a ledger entry is visible in `wam_inspect_provenance` output, it MUST also be visible in the user-facing inspection view for that element, and vice versa.

#### User-Facing Inspection Mechanism

The User Agent MUST implement at least one of:

*   **Context Menu:** A context menu item (e.g., "Inspect LLM Provenance") on right-click.
*   **Trust Panel:** A dedicated panel or sidebar showing provenance for the current page.
*   **Developer Tools:** A tab or section in the browser's developer tools.
*   **Keyboard Shortcut:** A keyboard command to inspect the focused element's provenance.

#### Disclosed Information

The inspection view MUST display:

*   **Source:** The `wam-provenance-source` URI, if present.
*   **Confidence:** The `wam-provenance-confidence` score, if present.
*   **Operations:** The complete `wam-provenance-operation` history as a parsed list.
*   **Ledger Entries:** All ledger entries associated with the element, including timestamps, original/new values, `orchestratingModelId`, and `generatingModelId` where applicable.
*   **Delegated Generation Indicator:** For entries where `generatingModelId` is populated and differs from `orchestratingModelId`, the inspection view MUST clearly indicate that a model other than the orchestrating LLM generated the value, and MUST display both model identifiers.
*   **Integrity Status:** Whether the element has any integrity violations.

#### Visual Indicators

The User Agent SHOULD provide optional visual indicators for LLM-modified content:

*   **Modified Indicator:** A subtle visual cue (icon, underline, background) on elements with `wam-provenance-operation` entries.
*   **Confidence Indicator:** Color-coded indicator based on `wam-provenance-confidence` (green for ≥ 0.8, yellow for 0.5–0.8, red for < 0.5).
*   **Delegated Generation Indicator:** A distinct icon or badge on elements where any ledger entry has a populated `generatingModelId` differing from `orchestratingModelId`, signalling that a model other than the orchestrating LLM generated the value.
*   **Violation Indicator:** Prominent visual cue for elements with integrity violations.

These indicators SHOULD be user-configurable (on, off, or hover-to-reveal).

### 9.9. Provenance Events

The User Agent MUST fire DOM events to allow pages to observe provenance changes and integrity violations. These events are the DOM-observable counterpart to the MCP tools `wam_inspect_provenance` and `wam_report_violation`: the same Record phase execution that triggers a ledger write and `wam-provenance-operation` append MUST also fire `llmprovenancechange` on the target element. Pages MAY listen to these events for custom logging or UI updates, but MUST NOT be able to suppress or modify integrity violation detection.

#### `llmprovenancechange` Event

Fired at the end of the Record phase execution sequence (§9.1), after the Provenance Ledger entry has been written and the `wam-provenance-operation` attribute has been updated.

```webidl
interface LLMProvenanceChangeEvent : Event {
  readonly attribute Element target;
  readonly attribute LLMProvenanceLayer layer;
  readonly attribute DOMString explanation;
  readonly attribute DOMHighResTimeStamp timestamp;
};
```

#### `llmintegrityviolation` Event

Fired when an integrity violation is detected (§9.5). The `wam_report_violation` MCP tool (§12.2) is the programmatic equivalent: when the orchestrating LLM calls `wam_report_violation`, the User Agent MUST treat it as equivalent to a self-detected violation and fire this event with the same semantics. The LLM cannot suppress the event by not calling the tool; integrity detection is always UA-driven.

```webidl
interface LLMIntegrityViolationEvent : Event {
  readonly attribute Element target;
  readonly attribute LLMProvenanceLayer layer;
  readonly attribute DOMString violationType;
  readonly attribute any originalValue;
  readonly attribute any currentValue;
  readonly attribute boolean reverted;
};
```

Pages MAY listen to these events for custom logging, analytics, or UI updates. Pages MUST NOT be able to suppress or modify integrity violation detection.

## 10. Shadow DOM Policy Boundaries

This section defines how Web Agent Markup policies interact with Shadow DOM encapsulation boundaries. The guiding principle is that **component authors have precedence** over page authors for content within their shadow trees, while **intersection semantics** ensure that permissions are only granted when both parties agree.

### 10.1. Core Principles

1.  **Component Author Precedence:** The author of a shadow root (component author) has final authority over policy decisions within that shadow tree. Page authors cannot override component policies.
2.  **Opt-Out Default:** Shadow roots constitute policy boundaries. By default, policies from the light DOM do NOT cross into shadow trees.
3.  **Opt-In Inheritance:** Component authors MAY explicitly opt into inheriting policies from the host element's context.
4.  **Intersection Semantics:** When inheritance is enabled, the effective policy is the intersection of inherited and local policies. Both component author and page author must agree for a permission to be granted.

### 10.2. Shadow Root as Policy Boundary

A shadow root creates an encapsulation boundary for Web Agent Markup policies. By default:

*   `wam-policy-*` attributes on ancestors of the shadow host do NOT apply to nodes within the shadow tree.
*   `wam-intent-*` attributes on ancestors of the shadow host do NOT propagate into the shadow tree.
*   Global Policy selectors (e.g., `block-selectors`, `category-rules`) do NOT match elements inside shadow trees.

Nodes within a shadow tree that lack explicit policy attributes fall back to the specification defaults, NOT to inherited values from the light DOM.

**Example (Default Behavior - No Inheritance):**

```html
<body wam-policy-input="none" wam-policy-output="readonly">
  <!-- Light DOM: hidden from LLM, readonly -->
  <my-widget>
    <!-- Shadow boundary blocks inheritance -->
    #shadow-root
      <div>
        <!-- Falls back to spec defaults: input=all, output=readonly -->
        <!-- Component content is VISIBLE to LLM despite page's input="none" -->
      </div>
  </my-widget>
</body>
```

### 10.3. Opt-In Policy Inheritance

A shadow root MAY opt into policy inheritance by specifying the `wam-policy-inherit` attribute on the shadow root's template or via the `attachShadow()` options.

**Declarative Shadow DOM:**

```html
<template shadowrootmode="open" wam-policy-inherit>
  <!-- Inherits all policy namespaces from host context -->
</template>

<template shadowrootmode="open" wam-policy-inherit="input memory">
  <!-- Inherits only specified namespaces; others use spec defaults -->
</template>
```

**Imperative Shadow DOM:**

```javascript
element.attachShadow({
  mode: 'open',
  wamPolicyInherit: true              // Inherit all namespaces
  // OR
  wamPolicyInherit: ['input', 'memory']  // Inherit specific namespaces
});
```

**Inheritance Values:**

*   `true` or empty attribute: Inherit all policy namespaces (`input`, `output`, `memory`).
*   Space-separated list (e.g., `"input memory"`): Inherit only the specified namespaces.
*   `false` or attribute absent: No inheritance (default).

### 10.4. Intersection Semantics for Inherited Policies

When a shadow root opts into inheritance, the effective policy for nodes within the shadow tree is computed as the **intersection** of:

1.  The inherited policy from the host element's context (including global policy defaults and constraints).
2.  Any local policy attributes specified within the shadow tree.

**Rule:** A permission is granted only if BOTH the inherited policy AND the local policy allow it. If either party omits or denies a permission, that permission is denied.

**Example (Intersection):**

```html
<body wam-policy-output="mutable">
  <my-widget>
    #shadow-root wam-policy-inherit
      <div wam-policy-output="style annotation">
        <!-- Inherited: mutable (all permissions) -->
        <!-- Local: style, annotation -->
        <!-- Effective: mutable ∩ (style annotation) = style annotation -->
        <!-- Component restricts page's broad permissions -->
      </div>
  </my-widget>
</body>
```

**Example (Component Restriction):**

```html
<body wam-policy-output="content annotation">
  <secure-viewer>
    #shadow-root wam-policy-inherit
      <div wam-policy-output="readonly">
        <!-- Inherited: content, annotation -->
        <!-- Local: readonly (no permissions) -->
        <!-- Effective: (content annotation) ∩ readonly = readonly -->
        <!-- Component enforces stricter policy -->
      </div>
  </secure-viewer>
</body>
```

### 10.5. Slotted Content

Slotted content presents a unique case: elements exist in the light DOM (page author's domain) but render visually within the shadow DOM (component author's domain). The effective policy for slotted content is the **intersection** of both contexts.

**Effective Policy Calculation for Slotted Elements:**

```
EffectivePolicy(slottedElement) =
    Policy(slottedElement)                    // Element's own attributes
  ∩ InheritedPolicy(lightDOMancestors)        // Light DOM inheritance chain
  ∩ SlotContextPolicy(shadowContainer)        // Shadow DOM slot container
```

**Rules:**

1.  The page author's policy on the slotted element (in light DOM) establishes a ceiling of permissions.
2.  The component author's policy on the slot's containing element establishes additional constraints.
3.  The effective policy is the intersection; both must agree for a permission to be granted.
4.  Component authors can RESTRICT what happens to slotted content but cannot EXPAND permissions beyond what the page author allowed.

**Example (Slotted Content):**

```html
<!-- Page author's light DOM -->
<my-secure-viewer>
  <p slot="content" wam-policy-output="mutable">
    Page author allows full mutability
  </p>
</my-secure-viewer>

<!-- Component author's shadow DOM -->
#shadow-root
  <div class="viewer-frame" wam-policy-output="readonly annotation">
    <slot name="content"></slot>
  </div>

<!-- Effective policy on <p>:
     Page policy (mutable) ∩ Slot context (readonly annotation)
     = annotation (only permission both agree on)
-->
```

### 10.6. Global Policy and Shadow DOM

Global Policy constraints (`block-selectors`, `category-rules`) do NOT pierce shadow boundaries by default. To apply global policies to shadow content:

1.  **Apply categories to the host element:** The page author marks the shadow host with `wam-intent-category`.
2.  **Component opts into inheritance:** The shadow root includes `wam-policy-inherit`.
3.  **Category rules propagate:** The inherited category triggers Global Policy rules within the shadow tree.

**Example:**

```html
<!-- Global Policy -->
{
  "constraints": {
    "category-rules": {
      "advertisement": { "wam-policy-input": ["none"] }
    }
  }
}

<!-- Page author marks host -->
<ad-component wam-intent-category="advertisement">
  #shadow-root wam-policy-inherit
    <div>
      <!-- Inherits category="advertisement" from host -->
      <!-- Global category-rule applies: input=none -->
      <!-- Shadow content is hidden from LLM -->
    </div>
</ad-component>
```

**Without Inheritance:**

```html
<ad-component wam-intent-category="advertisement">
  #shadow-root  <!-- No wam-policy-inherit -->
    <div>
      <!-- Category NOT inherited; global rule does NOT apply -->
      <!-- Shadow content uses spec defaults (visible) -->
      <!-- Component controls its own visibility -->
    </div>
</ad-component>
```

### 10.7. Provenance and Shadow DOM

Provenance tracking serves auditability requirements that may override normal encapsulation. The User Agent MUST track mutations across all shadow boundaries, but the level of detail disclosed is controlled by the component author.

**Mandatory Reporting:**

*   Mutations within shadow trees MUST be reported to the document's provenance ledger.
*   The User Agent MUST record that mutations occurred, even if details are not disclosed.

**Detail Level Control:**

By default, mutations within shadow roots are reported in **aggregated form** (mutation count per layer). Component authors MAY opt into full transparency.

**Declarative:**

```html
<template shadowrootmode="open" wam-provenance-transparent>
  <!-- Full mutation details reported to document ledger -->
</template>
```

**Imperative:**

```javascript
element.attachShadow({
  mode: 'open',
  wamProvenanceTransparent: true
});
```

**Ledger Entry Formats:**

*   **Default (Aggregated):**
    ```
    <my-widget> [shadow-root: 3 mutations]
      ├─ content: 2 operations
      └─ style: 1 operation
    ```
*   **Transparent (Full Detail):**
    ```
    <my-widget> [shadow-root]
      ├─ <p> content:summarized-text
      ├─ <span> content:corrected-spelling
      └─ <div> style:highlighted-warning
    ```

**Integrity Requirement:**

The User Agent MUST NOT allow component authors to completely hide that mutations occurred. Users can always determine that a shadow root contains modified content, even if specific details are aggregated.

### 10.8. Nested Shadow DOM

Each shadow boundary requires explicit opt-in for inheritance. Inheritance does NOT cascade automatically through nested shadow roots.

**Example:**

```html
<component-a>
  #shadow-root wam-policy-inherit        <!-- A inherits from page -->
    <component-b>
      #shadow-root                       <!-- B does NOT auto-inherit -->
        <div>
          <!-- Falls back to spec defaults -->
          <!-- Does NOT inherit A's effective policy -->
        </div>
    </component-b>
</component-a>
```

**For nested inheritance:**

```html
<component-a>
  #shadow-root wam-policy-inherit        <!-- A inherits from page -->
    <component-b>
      #shadow-root wam-policy-inherit    <!-- B explicitly inherits from A -->
        <div>
          <!-- Inherits A's effective policy -->
          <!-- Which already includes page's policy (intersected) -->
        </div>
    </component-b>
</component-a>
```

**Intersection Chain:**

```
Page policy
  ∩ Component A's local policy (A opted in)
  ∩ Component B's local policy (B opted in)
= Final effective policy inside B
```

### 10.9. Recommendations for Component Authors

*   **General-purpose components** (date pickers, modals, tooltips) SHOULD opt into policy inheritance (`wam-policy-inherit`) to respect page-level policies.
*   **Security-sensitive components** (password managers, payment forms, authentication widgets) SHOULD NOT inherit policies and SHOULD enforce `wam-policy-input="none"` or `wam-policy-output="readonly"` explicitly.
*   **Components displaying user-generated content** SHOULD inherit input policies but MAY enforce output restrictions.
*   **All components** SHOULD document their Web Agent Markup behavior for page authors.

