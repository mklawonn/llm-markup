<pre class='metadata'>
Title: LLM Markup (LLMPM)
Shortname: llm-markup
Level: 1
Status: ED
Group: LLM Markup Community Group
URL: https://example.org/llm-markup
Editor: [Your Name/Organization]
Abstract: A declarative transformation contract embedded in HTML to govern LLM agent behavior.
Markup Shorthands: markdown yes
</pre>

# Namespaces and Attributes

## The LLM-Intent Namespace

The `llm-intent` namespace defines soft constraints and semantic signals that help the User Agent construct a deterministic context for the LLM. Unlike policy attributes, these do not strictly enforce visibility or mutability by default, but provide metadata that can be targeted by policies.

### The llm-policy-license attribute
Specifies the usage license for the content, acting as a policy macro that enforces rights and restrictions.

*   **Syntax:** `llm-policy-license="<SPDX-Identifier>"`
*   **Purpose:** Machine-readable declaration of rights (e.g., `CC-BY-4.0`, `MIT`, `GPL-3.0`). The User Agent MUST enforce the terms associated with the license (e.g., restricting commercial use, requiring attribution, or enforcing copyleft on output).

## The LLM-Provenance Namespace

The `llm-provenance` namespace provides metadata about the origin and history of the content, facilitating audit trails and attribution.

### The llm-provenance-attribution attribute
Specifies the required attribution text for the content.

*   **Syntax:** `llm-provenance-attribution="<string>"`
*   **Purpose:** Defines the text that MUST accompany the content if it is used or transformed by the LLM (e.g., "Source: The New York Times"). This acts as the data payload for any attribution requirements enforced by `llm-policy-license`.

## The LLM-Intent Namespace

The `llm-intent` namespace defines soft constraints and semantic signals that help the User Agent construct a deterministic context for the LLM. Unlike policy attributes, these do not strictly enforce visibility or mutability by default, but provide metadata that can be targeted by policies.

### The llm-intent-category attribute
Assigns a semantic category to a node, allowing it to be targeted by Global Policy rules or specific LLM instructions.

*   **Syntax:** `llm-intent-category="<string>"`
*   **Purpose:** Provides a stable, semantic label (e.g., "quote", "advertisement", "navigation") independent of CSS classes or visual presentation.

### The llm-intent-importance attribute
Specifies the relative priority of the content within the document topology.

*   **Syntax:** `llm-intent-importance="critical|high|normal|low|background"`
*   **Purpose:** Guides the User Agent in prioritizing content for the LLM context. `critical` content MUST be preserved if token limits are reached, while `background` content MAY be discarded.

### The llm-intent-entity attribute
Links the content to a specific real-world entity for disambiguation.

*   **Syntax:** `llm-intent-entity="<URI>"`
*   **Purpose:** Provides a canonical reference (e.g., Wikidata ID, Schema.org URL) to ground the LLM's understanding of named entities.

### The llm-intent-instruction attribute
Provides explicit, free-form instructions to the LLM for processing the specific node.

*   **Syntax:** `llm-intent-instruction="<string>"`
*   **Purpose:** Allows developers to bypass standard templates and inject custom prompts. This attribute **overrides** the default prompt generation for Category, Function, and Tone, but preserves semantic identity for Policy enforcement.

### The llm-intent-function attribute
Defines the interactive purpose of an element (Phase 2).

*   **Syntax:** `llm-intent-function="<string>"`
*   **Purpose:** Semantic label for interactive controls (e.g., "search", "submit"). See the Standardized Lexicon for normative terms. Custom values are accepted.

### The llm-intent-workflow attribute
Defines the role of an element within a multi-step process (Phase 2).

*   **Syntax:** `llm-intent-workflow="<string>"`
*   **Purpose:** Semantic label for workflow states (e.g., "step", "prerequisite"). See the Standardized Lexicon for normative terms. Custom values are accepted.

### The llm-intent-output attribute
Specifies the desired format for the LLM's response (Phase 3).

*   **Syntax:** `llm-intent-output="<string>"`
*   **Purpose:** Instructions for response shaping (e.g., "json", "concise"). See the Standardized Lexicon for normative terms. Custom values are accepted.

### The llm-intent-tone attribute
Specifies the desired persona or tone for the LLM's response (Phase 3).

*   **Syntax:** `llm-intent-tone="<string>"`
*   **Purpose:** Instructions for stylistic adaptation (e.g., "formal", "empathetic"). See the Standardized Lexicon for normative terms. Custom values are accepted.

The `llm-policy` namespace defines hard constraints that a conforming User Agent MUST enforce. These are split into three primary attributes to govern the flow of information and mutations.

### The llm-policy-input attribute
Governs the flow of data from the DOM to the Language Model (Visibility). This attribute accepts a **space-separated list** of allowed information channels. The User Agent MUST construct the context using the union of these channels.

*   **`none` (Default):** The node is completely hidden from the LLM.
*   **`structure`:** The LLM may see the element and its attributes (subject to filtering), but not its text content or children.
*   **`text`:** The LLM may see the text content of the node.
*   **`attributes`:** The LLM may see the attributes of the node.
*   **`media`:** The LLM may see media content (images, audio, video).
*   **`all`:** Shorthand for `structure text attributes media`.

**Example:** `llm-policy-input="structure text"` creates a "Masked" view where the structure and text are visible, but attributes (like PII in `data-user-id`) are hidden.

### The llm-policy-output attribute
Governs the flow of mutations from the Language Model to the DOM (Enforcement). This attribute accepts a **space-separated list** of permission tokens. The User Agent MUST grant the union of all permissions specified.

*   **`readonly` (Default):** No mutations are permitted.
*   **`style`:** Grants permission to modify the Presentation Layer (CSS/Classes).
*   **`interaction`:** Grants permission to modify the Interaction Layer (Scripts/Event Handlers/State).
*   **`layout`:** Grants permission to reorder child nodes (formerly `reorder-only`).
*   **`annotation`:** Grants permission to wrap text nodes without changing content.
*   **`content`:** Grants permission to modify the Content Layer (Text).
*   **`data`:** Grants permission to modify Machine-Readable Payloads (Values, Data Attributes).
*   **`append`:** Grants permission to append new children.
*   **`mutable`:** Shorthand for all permissions.

**Example:** `llm-policy-output="style annotation"` allows highlighting and styling but prevents text alteration.

### The llm-policy-memory attribute
Governs the persistence of interaction data (Retention). This attribute accepts a **space-separated list** of allowed storage scopes.

*   **`none` (Default):** Ephemeral processing only.
*   **`session`:** Data may be retained for the duration of the current browsing session.
*   **`user`:** Data may be stored in the user's long-term profile (e.g., "Remember I like dark mode").
*   **`training`:** Data may be used to train or fine-tune the global model.

**Example:** `llm-policy-memory="session user"` allows personalization but prohibits using the data for model training.

# Global Policy Header

A server MAY provide a global policy via a JSON-encoded payload. This payload defines default behaviors and immutable constraints for the entire document.

## JSON Schema

The global policy is defined as a JSON object. This schema enforces site-wide defaults and specific constraints, such as blocking specific selectors or enforcing co-occurrence dependencies (e.g., preventing a quote from appearing without its citation).

```json
{
  "report-to": "https://api.example.com/llm-reports",
  "report-only": true,
  "defaults": {
    "llm-policy-input": ["structure", "text", "attributes", "media"],
    "llm-policy-output": ["readonly"],
    "llm-policy-memory": ["none"]
  },
  "constraints": {
    "block-selectors": ["css-selector", "..."],
    "category-rules": {
      "advertisement": { "llm-policy-input": ["none"] },
      "quote": { "llm-policy-output": ["readonly"] }
    },
    "dependencies": [
      {
        "trigger": ".pull-quote",
        "requires": ".attribution-context",
        "scope": "input",
        "failure-mode": "omit-trigger"
      }
    ]
  }
}
```

### Constraint Types
*   **`block-selectors`:** Forcibly removes elements matching the CSS selector from the LLM's view.
*   **`category-rules`:** Maps an `llm-intent-category` value (e.g., `advertisement`) to specific policy enforcements (e.g., `block`). This allows semantic control over policy without relying on brittle CSS classes.
*   **`dependencies`:** Enforces co-occurrence of elements to maintain context (e.g., requiring a citation for a quote).

### Policy Reporting

The Global Policy Header supports a reporting mechanism to help developers audit compliance and debug policy configurations without breaking functionality.

*   **`report-to` (URI):** Specifies the endpoint where the User Agent SHOULD send violation reports. The reports are sent as JSON payloads containing details about the attempted mutation, the violated policy, and the target element.
*   **`report-only` (Boolean):** If `true`, the User Agent MUST enforce policies in **Audit Mode**. Violations are reported to the `report-to` endpoint, but the mutations themselves are **allowed** to proceed. This is critical for safely rolling out restrictive policies on live sites.

## Precedence and Inheritance

1.  **Constraints:** Constraints defined in the global policy header MUST NOT be overridden by local DOM attributes.
2.  **Local Overrides:** Local attributes (e.g., `llm-policy-output="mutable"`) override the global `defaults` unless a constraint prevents it.
3.  **Inheritance:** Attributes on a node apply to all its descendants unless a descendant specifies its own attribute.

# Processing Model

This section defines the normative requirements for User Agents when enforcing mutation policies. The User Agent MUST calculate the **Effective Permission Set** as the union of all tokens present in the `llm-policy-output` attribute.

## 1. The Semantic Payload Principle (Core Constraint)

Regardless of the permission set, the User Agent MUST determine the mutability of any specific attribute or node based on its semantic role.

*   **Immutable Payload (Identity & Reference):** Attributes defining identity (`id`, `name`), structure (`for`, `headers`), or data source/destination (`src`, `href`, `action`, `data`) are **strictly readonly** unless the `mutable` token is explicitly present.
*   **Mutable State (Presentation & Interaction):** Attributes defining visual style (`class`, `style`) or transient state (`aria-*`, `checked`, `open`) are subject to specific permission tokens.

## 2. Global Policy Resolution (Category Conflicts)

When multiple `llm-intent-category` values apply to a single node, and the Global Policy defines conflicting rules for these categories, the User Agent MUST resolve the conflict using **Intersection Logic** (Restrictive Priority).

*   **Rule:** The effective permission set granted by the Global Policy is the **intersection** of the allowed tokens for each applicable category.
*   **Implication:** If *any* active category rule forbids a specific action (by omitting the corresponding token), that action is forbidden, even if other categories would allow it.
*   **Example:**
    *   Category A (`user-content`) allows: `content`, `interaction`.
    *   Category B (`archived`) allows: `readonly` (empty set).
    *   **Result:** `content` AND `interaction` AND `(empty)` = `readonly`.

## 3. Token-Based Enforcement

The User Agent MUST allow a mutation if and only if it is authorized by at least one token in the Effective Permission Set.

### `style` (Presentation Layer)
*   **Allowed:** Modification of `class` and `style` attributes.
*   **Blocked:** Everything else.

### `interaction` (Behavioral Layer)
*   **Allowed:**
    *   Modification of `class`, `style`.
    *   Modification of Event Handlers (`on*`) and ARIA states (`aria-*`).
    *   Modification of global interaction attributes (`tabindex`, `hidden`, `contenteditable`, `draggable`, `spellcheck`).
    *   Insertion of `<script>` and `<style>` elements.
    *   Modification of Form State (`checked`, `selected`, `disabled`, `readonly`, `open`).
*   **Blocked:** Modification of Text Nodes, Payload Attributes (`src`, `href`, `id`), and Data Values (`value`, `data-*`).

### `layout` (Structural Reordering)
*   **Allowed:** Reordering (permuting) of direct child nodes.
*   **Blocked:** Modification, addition, or removal of child nodes.

### `annotation` (Non-Destructive Wrapping)
*   **Allowed:** Splitting text nodes and wrapping them in inline elements (e.g., `<span>`, `<mark>`, `<a>`).
*   **Constraint:** The concatenated `textContent` of the parent element MUST remain identical.
*   **Blocked:** Changing the text characters themselves.

### `content` (Text Layer)
*   **Allowed:** Modification of Text Nodes.
*   **Blocked:** Changing the DOM structure or attributes of container elements.

### `data` (Machine-Readable Payload)
*   **Allowed:**
    *   **Form Values:** Modification of the `value` attribute on form controls.
    *   **Data Attributes:** Modification of custom `data-*` attributes.
    *   **Meta Content:** Modification of the `content` attribute on `<meta>` tags.
    *   **Data Blocks:** Modification of text content within `<script>` tags that have a data MIME type (e.g., `application/ld+json`, `application/json`) but NOT executable scripts (`text/javascript`).
*   **Blocked:** Modification of Rendered Text Nodes or Document Structure.

### `append` (Additive Structure)
*   **Allowed:** Insertion of new child nodes (elements or text) at the end of the child list.
*   **Blocked:** Modification or removal of existing siblings.

### `mutable` (Full Access)
*   **Allowed:** All operations. The User Agent removes all restrictions for this node.

## 4. Enforcement of Visibility (`llm-policy-input`)

The User Agent MUST transform the DOM into a context representation (e.g., HTML string, Accessibility Tree) for the LLM by filtering nodes based on the `llm-policy-input` tokens. The effective visibility is the union of all allowed channels.

*   **`none` (Omission):** If the effective set is empty or explicitly `none`, the User Agent MUST omit the node and all its descendants from the context. It appears as if it does not exist.
*   **`structure` (Skeleton):**
    *   The element tag MUST be preserved.
    *   Text nodes MUST be replaced with an empty string or a generic placeholder (e.g., `[REDACTED]`).
    *   Attributes are filtered based on the presence of the `attributes` token.
*   **`text` (Content):**
    *   Text nodes MUST be preserved.
*   **`attributes` (Metadata):**
    *   Attributes MUST be preserved.
    *   *Constraint:* If `structure` is present but `attributes` is NOT, the User Agent MUST strip all attributes except `id`, `class`, and `llm-*` metadata.
*   **`media` (Visuals):**
    *   Media-specific attributes (`src`, `alt`, `poster`, `srcset`) MUST be preserved on `<img>`, `<video>`, `<audio>`, and `<source>` elements.
    *   If `media` is NOT present, these attributes MUST be stripped or redacted.

**Default Behavior:** If no attribute is present, the default is `structure text attributes media` (Full Visibility), unless overridden by the Global Policy.

## 5. Enforcement of Retention (`llm-policy-memory`)

The User Agent MUST signal and enforce storage limitations based on the `llm-policy-memory` tokens.

*   **`none` (Ephemeral):**
    *   **Signal:** The User Agent MUST send a standard HTTP header (e.g., `Cache-Control: no-store`) or an equivalent signal to the LLM service indicating that the context is ephemeral.
    *   **Storage:** The User Agent MUST NOT persist the interaction content in any persistent storage (e.g., `localStorage`, `IndexedDB`) beyond the lifespan of the request/response cycle.
*   **`session` (Context Window):**
    *   **Signal:** Allows session-scoped context.
    *   **Storage:** The User Agent MAY store the interaction in `sessionStorage` or equivalent ephemeral memory until the browser tab or session is closed.
*   **`user` (Profile):**
    *   **Signal:** Allows long-term user profile updates.
    *   **Storage:** The User Agent MAY persist specific facts or preferences derived from the interaction into the user's long-term profile storage (e.g., `localStorage`, synced settings).
*   **`training` (Model Improvement):**
    *   **Signal:** Explicitly authorizes the use of the interaction data for training or fine-tuning the underlying model.
    *   **Default:** Without this token, the User Agent MUST signal `Do-Not-Train` or equivalent.

**Privacy Default:** If no attribute is present, the default is `none` (Strictly Ephemeral).

## 6. Enforcement of Licensing (`llm-policy-license`)

The User Agent MUST resolve `llm-policy-license` attributes by expanding the license identifier into a set of implicit policy constraints (a **License Profile**). The effective policy for the node is the **intersection** of the explicitly declared `llm-policy-output` tokens and the License Profile's allowed permissions.

### License Profile Examples (Informative)
The User Agent SHOULD support standard SPDX identifiers with the following implicit profiles:

*   **`CC-BY-ND` (No Derivatives):**
    *   **Allowed:** `readonly`, `annotation` (if non-destructive).
    *   **Blocked:** `mutable`, `content`, `reorder`, `append`.
*   **`GPL-*` (Copyleft/Viral):**
    *   **Constraint:** Any output generated from this content MUST carry a compatible license.
    *   **Blocked:** Insertion into contexts marked as `proprietary` or incompatibly licensed.
*   **`Public Domain` / `CC0`:**
    *   **Allowed:** All permissions (`mutable`).

**Conflict Resolution:** If an explicit attribute (e.g., `llm-policy-output="mutable"`) conflicts with the License Profile (e.g., `CC-BY-ND` implying `readonly`), the **License Profile takes precedence** (Intersection Logic), and the conflicting permissions are revoked. The User Agent MAY emit a warning.

## 7. Dependency Resolution (Global Policy)

When constructing the LLM context, the User Agent MUST enforce dependency constraints defined in the Global Policy Header.

1.  **Dependency Graph Construction:** The User Agent identifies all nodes selected for inclusion in the context (Candidate Set).
2.  **Constraint Check:** For each node in the Candidate Set, the User Agent checks if it matches any `trigger` selector defined in the Global Policy's `dependencies` list.
3.  **Requirement Verification:**
    *   If a node matches a `trigger`, the User Agent MUST verify that at least one node matching the `requires` selector is also present in the Candidate Set.
4.  **Failure Resolution:**
    *   If the Requirement Verification fails, the User Agent applies the `failure-mode`:
        *   **`omit-trigger` (Default):** The triggering node is **removed** from the Candidate Set. The User Agent then re-evaluates dependency constraints recursively.
        *   **`error`:** The context construction process is halted, and the User Agent reports a dependency violation error.

## 8. Intent Processing Model (Prompt Construction)

This section defines how the User Agent translates `llm-intent` attributes into the system prompt or context object provided to the LLM.

### 8.1. Hierarchy of Instruction
The User Agent MUST determine the final instruction for a node based on the following precedence:

1.  **`llm-intent-instruction` (Highest):** If present, the value of this attribute is used directly as the instruction. It overrides any instructions derived from Category, Function, Workflow, Output, or Tone attributes.
    *   *Note:* The semantic values of overridden attributes (e.g., `llm-intent-category`) are preserved for **Policy Routing** but ignored for **Prompt Construction**.
2.  **Standardized Lexicon (Optimized):** If an attribute value matches a term in the **Standardized Intent Lexicon**, the User Agent MUST use the corresponding **Optimized System Prompt** defined in the lexicon.
3.  **Custom Value (Fallback):** If an attribute value is not found in the lexicon, the User Agent MUST construct the instruction using the **Fallback Template** for that attribute type.

### 8.2. Fallback Templates

For custom values not in the Standardized Lexicon, the User Agent MUST use the following templates:

*   **Category:** `"Treat the following content as a(n) [value]."`
*   **Function:** `"Use this control to [value]."`
*   **Workflow:** `"(Workflow Stage: [value])"`
*   **Output:** `"Format your response as [value]."`
*   **Tone:** `"Adopt a(n) [value] tone."`

### 8.3. Entity & Importance (Independent Layers)

These attributes operate independently of the Instruction/Category hierarchy and are appended to the context.

*   **`llm-intent-entity`:** Appends an entity reference anchor.
    *   **Template:** `[Content] (Entity Reference: [URI])`
*   **`llm-intent-importance`:** Maps to specific prioritization instructions.
    *   **`critical`:** `"Pay maximum attention to the following content. It is essential for the user's task."`
    *   **`high`:** `"Prioritize this content."`
    *   **`normal`:** (No instruction).
    *   **`low`:** `"This content is supplementary. You may ignore it if context is limited."`
    *   **`background`:** `"This is background information only. Do not focus on it unless explicitly asked."`

