<pre class='metadata'>
Title: LLM Markup (LLMPM)
Shortname: llm-markup
Level: 1
Status: ED
Group: LLM Markup Community Group
URL: https://example.org/llm-markup
Editor: [Your Name/Organization]
Abstract: A declarative transformation contract embedded in HTML to govern LLM agent behavior.
Markup Shorthands: markdown yes
</pre>

# Namespaces and Attributes

## The LLM-Intent Namespace

The `llm-intent` namespace defines soft constraints and semantic signals that help the User Agent construct a deterministic context for the LLM. Unlike policy attributes, these do not strictly enforce visibility or mutability by default, but provide metadata that can be targeted by policies.

### The llm-policy-license attribute
Specifies the usage license for the content, acting as a policy macro that enforces rights and restrictions.

*   **Syntax:** `llm-policy-license="<SPDX-Identifier>"`
*   **Purpose:** Machine-readable declaration of rights (e.g., `CC-BY-4.0`, `MIT`, `GPL-3.0`). The User Agent MUST enforce the terms associated with the license (e.g., restricting commercial use, requiring attribution, or enforcing copyleft on output).

## The LLM-Provenance Namespace

The `llm-provenance` namespace provides metadata about the origin and history of the content, facilitating audit trails and attribution.

### The llm-provenance-attribution attribute
Specifies the required attribution text for the content.

*   **Syntax:** `llm-provenance-attribution="<string>"`
*   **Purpose:** Defines the text that MUST accompany the content if it is used or transformed by the LLM (e.g., "Source: The New York Times"). This acts as the data payload for any attribution requirements enforced by `llm-policy-license`.

## The LLM-Intent Namespace

The `llm-intent` namespace defines soft constraints and semantic signals that help the User Agent construct a deterministic context for the LLM. Unlike policy attributes, these do not strictly enforce visibility or mutability by default, but provide metadata that can be targeted by policies.

### The llm-intent-category attribute
Assigns a semantic category to a node, allowing it to be targeted by Global Policy rules or specific LLM instructions.

*   **Syntax:** `llm-intent-category="<string>"`
*   **Purpose:** Provides a stable, semantic label (e.g., "quote", "advertisement", "navigation") independent of CSS classes or visual presentation.

The `llm-policy` namespace defines hard constraints that a conforming User Agent MUST enforce. These are split into three primary attributes to govern the flow of information and mutations.

### The llm-policy-input attribute
Governs the flow of data from the DOM to the Language Model (Redaction and Visibility).

*   **`allow` (Initial):** The User Agent MUST include the node and its descendants in the LLM context.
*   **`block`:** The User Agent MUST omit the node and its descendants from the context.
*   **`mask`:** The User Agent MUST preserve the structure but replace text content with placeholders.
*   **`summary`:** The User Agent MUST replace the node's content with a summary before transmission.

### The llm-policy-output attribute
Governs the flow of mutations from the Language Model to the DOM (Enforcement).

*   **`readonly` (Initial):** The User Agent MUST reject all mutations targeting this node.
*   **`mutable`:** The User Agent MAY accept mutations across all layers.
*   **`append-only`:** The User Agent MUST allow insertion of children but reject modification of existing content.
*   **`style-only`:** The User Agent MUST allow modifications to the Presentation Layer (CSS/Classes) only.
*   **`interaction-only`:** The User Agent MUST allow modifications to the Interaction Layer (Scripts/Event Handlers) but reject changes to existing text content or structure.
*   **`content-only`:** The User Agent MUST allow modifications to the Content Layer (Text) only.

### The llm-policy-memory attribute
Governs the persistence of interaction data (Privacy).

*   **`no-store` (Initial):** The User Agent MUST signal that the content is ephemeral and MUST NOT be used for training or long-term recall.
*   **`persist`:** The User Agent MAY allow long-term retention of the interaction data.

# Global Policy Header

A server MAY provide a global policy via a JSON-encoded payload. This payload defines default behaviors and immutable constraints for the entire document.

## JSON Schema

The global policy is defined as a JSON object. This schema enforces site-wide defaults and specific constraints, such as blocking specific selectors or enforcing co-occurrence dependencies (e.g., preventing a quote from appearing without its citation).

```json
{
  "defaults": {
    "llm-policy-input": "allow|block|mask|summary",
    "llm-policy-output": "readonly|mutable|...",
    "llm-policy-memory": "no-store|persist"
  },
  "constraints": {
    "block-selectors": ["css-selector", "..."],
    "category-rules": {
      "advertisement": { "llm-policy-input": "block" },
      "quote": { "llm-policy-output": "readonly" }
    },
    "dependencies": [
      {
        "trigger": ".pull-quote",
        "requires": ".attribution-context",
        "scope": "input",
        "failure-mode": "omit-trigger"
      }
    ]
  }
}
```

### Constraint Types
*   **`block-selectors`:** Forcibly removes elements matching the CSS selector from the LLM's view.
*   **`category-rules`:** Maps an `llm-intent-category` value (e.g., `advertisement`) to specific policy enforcements (e.g., `block`). This allows semantic control over policy without relying on brittle CSS classes.
*   **`dependencies`:** Enforces co-occurrence of elements to maintain context (e.g., requiring a citation for a quote).

## Precedence and Inheritance

1.  **Constraints:** Constraints defined in the global policy header MUST NOT be overridden by local DOM attributes.
2.  **Local Overrides:** Local attributes (e.g., `llm-policy-output="mutable"`) override the global `defaults` unless a constraint prevents it.
3.  **Inheritance:** Attributes on a node apply to all its descendants unless a descendant specifies its own attribute.

# Processing Model

This section defines the normative requirements for User Agents when enforcing mutation policies.

## Enforcement of `interaction-only`

The User Agent MUST determine the mutability of a node or attribute based on the **Semantic Payload Principle**. This principle separates the document into **Immutable Payload** (Content/Identity) and **Mutable State** (Presentation/Interaction).

### 1. Immutable Payload (Identity & Reference)
Attributes and nodes that define the identity, data source, or semantic value of information are strictly **Read-Only**.

*   **Text Nodes:** The text content of existing nodes MUST NOT be altered.
*   **Referential Integrity (Pointers):** Attributes that establish identity or structural relationships (e.g., `id`, `name`, `for`, `headers`) define the document topology and MUST NOT be mutated.
*   **Resource Identifiers (URIs):** Attributes that define the *source* or *destination* of data (e.g., `src`, `href`, `data`, `action`, `cite`) define the content payload and MUST NOT be mutated.
*   **Semantic Metadata:** Attributes that provide non-visual data essential to the meaning (e.g., `alt`, `value` (unless user-editable), `datetime`) MUST NOT be mutated.

### 2. Mutable State (Presentation & Interaction)
Attributes and nodes that define the visual presentation, transient state, or behavioral logic are **Mutable**.

*   **Visual Presentation:** Attributes governing visual rendering (e.g., `style`, `class`, `hidden`) belong to the Presentation Layer and MAY be mutated.
*   **Interaction State:** Attributes reflecting user interface state (e.g., `open`, `checked`, `selected`, `disabled`, `tabindex`, `aria-*`) belong to the Interaction Layer and MAY be mutated.
*   **Behavioral Logic:** Event handlers (e.g., `onclick`) and the insertion of purely functional elements (e.g., `<script>`, `<style>`) MAY be mutated or added.

### 3. Conflict Resolution
If an attribute's category is ambiguous (e.g., a custom `data-*` attribute), the User Agent SHOULD default to **Immutable** unless the attribute is explicitly whitelisted by a higher-level policy or heuristics confirm it is purely presentational.

## Enforcement of `style-only` (Presentation Layer)

The User Agent MUST strictly limit mutations to attributes defined as **Presentation Attributes**.

*   **Allowed Attributes:**
    *   `class`: The primary mechanism for CSS selection.
    *   `style`: Inline CSS properties.
*   **Blocked Attributes:**
    *   **Identity:** `id`, `name`.
    *   **Interaction/State:** `aria-*`, `tabindex`, `hidden`, `checked`, `selected`, `disabled`, `open`.
    *   **Behavior:** Event handlers (e.g., `onclick`).
    *   **Content:** Text nodes and resource attributes (`src`, `href`).

## Enforcement of `interaction-only` (Behavioral Layer)

The User Agent MUST allow mutations to the **Presentation Layer** and the **Interaction Layer**, but strictly forbid changes to the **Content Layer**.

*   **Allowed Attributes (Additive):**
    *   **Presentation:** `class`, `style`.
    *   **ARIA States & Properties:** All attributes matching `aria-*`.
    *   **Global Interaction Attributes:** `tabindex`, `accesskey`, `contenteditable`, `draggable`, `spellcheck`, `hidden`.
    *   **Form Control State:** `checked`, `selected`, `disabled`, `readonly`, `required`, `open`.
    *   **Event Handlers:** All attributes matching `on*` (e.g., `onclick`, `onmouseover`).
*   **Blocked Attributes (Immutable):**
    *   **Identity:** `id`, `name`, `for`.
    *   **Content/Source:** `src`, `href`, `data`, `action`, `cite`, `value` (unless user-editable), `alt`, `datetime`.
*   **Allowed Element Insertions:**
    *   Scripts: `<script>` tags may be inserted.
    *   Styles: `<style>` tags may be inserted.
    *   UI Elements: New elements may be inserted as long as they do not replace existing content nodes.
