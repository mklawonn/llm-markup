<pre class='metadata'>
Title: Web Agent Markup (WAM)
Shortname: web-agent-markup
Level: 1
Status: ED
Group: Web Agent Markup Community Group
URL: https://example.org/web-agent-markup
Editor: [Your Name/Organization]
Abstract: A declarative transformation contract embedded in HTML to govern LLM agent behavior.
Markup Shorthands: markdown yes
</pre>

# Namespaces and Attributes

## The WAM-Intent Namespace

The `wam-intent` namespace defines soft constraints and semantic signals that help the User Agent construct a deterministic context for the LLM. Unlike policy attributes, these do not strictly enforce visibility or mutability by default, but provide metadata that can be targeted by policies.

### The wam-policy-license attribute
Specifies the usage license for the content, acting as a policy macro that enforces rights and restrictions.

*   **Syntax:** `wam-policy-license="<SPDX-Identifier>"`
*   **Purpose:** Machine-readable declaration of rights (e.g., `CC-BY-4.0`, `MIT`, `GPL-3.0`). The User Agent MUST enforce the terms associated with the license (e.g., restricting commercial use, requiring `wam-provenance-citation`, or enforcing copyleft on output).

## The WAM-Provenance Namespace

The `wam-provenance` namespace functions as the DOM-visible face of the **Record phase** in the Tool Lifecycle Model (§11). After every successful mutation tool call, the User Agent MUST update the target element's provenance attributes and write a corresponding Provenance Ledger entry as a single atomic operation. The attributes in this namespace serve a dual purpose: they are readable by authors and page scripts as an interchange format, and they are the authoritative input to the `wam_inspect_provenance` MCP tool. The User Agent is always the **append authority** — authors MUST NOT modify these attributes after initial page load; any such modification constitutes a tamper event (§9.5).

See §9 for the full normative Record phase processing model.

### The wam-provenance-source attribute
Specifies the canonical origin URI of the content chunk.

*   **Syntax:** `wam-provenance-source="<URI>"`
*   **Purpose:** Tracks where the information came from (e.g., `https://wikipedia.org`, `urn:internal:knowledge-base`). Used for linking citations.
*   **Record phase role:** Authors MAY set this attribute on original content to declare its source. For content synthesized by a scoped LLM call (e.g., via `wam_append_child` with `instruction`), the User Agent SHOULD set this attribute to a UA-defined provenance URI identifying the generating model and session. The User Agent MUST NOT overwrite an author-supplied value; it MUST instead append a separate provenance record.
*   **Tool:** `wam_inspect_provenance` returns this field as `source` in the element's provenance object.

### The wam-provenance-operation attribute
The primary Record phase output: an append-only DOM ledger of transformations applied to the element.

*   **Syntax:** `wam-provenance-operation="<layer>:<explanation> ..."`
*   **Format:** A space-separated list of pairs, where `<layer>` is one of `content`, `style`, `interaction`, `topology`, `data`, or `intent`, and `<explanation>` is a succinct, hyphenated summary of the rationale.
*   **Example:** `content:summarized-text style:highlighted-warnings`
*   **Purpose:** Provides a granular audit trail of *why* and *how* the Agent modified the node.
*   **Record phase role:** After every mutation tool call completes, the User Agent MUST atomically append a `<layer>:<explanation>` token to this attribute (see §9.1). Authors MAY pre-populate this attribute on AI-pre-processed content delivered from the server; the UA treats pre-existing entries as baseline provenance and MUST NOT remove them.
*   **Tool:** `wam_inspect_provenance` returns the full operation history as a parsed list. Each mutation tool's Record phase targets this attribute.

### The wam-provenance-confidence attribute
Expresses the generating agent's certainty in the accuracy of the content.

*   **Syntax:** `wam-provenance-confidence="<0.0-1.0>"`
*   **Purpose:** Allows the User Agent to flag low-confidence information (e.g., hallucination warnings) or high-confidence facts in the UI.
*   **Record phase role:** For direct-value mutations (where the orchestrating LLM supplies `value` directly), the User Agent MAY set this to a default high value (e.g., `1.0`). For scoped LLM calls, the User Agent SHOULD set this to the generating model's expressed confidence if available, or `null` if confidence is not determinable. The value is set once per mutation; subsequent mutations to the same element SHOULD update the attribute only if confidence changes.
*   **Tool:** `wam_inspect_provenance` returns this field as `confidence`. The UI SHOULD render a visual indicator based on this value (§9.8).

### The wam-provenance-citation attribute
Specifies the human-readable attribution label for the source.

*   **Syntax:** `wam-provenance-citation="<string>"`
*   **Purpose:** Defines the text to display for attribution (e.g., "[1]", "TechRadar", "Jane Doe"). Replaces the legacy `wam-provenance-attribution` attribute.
*   **Record phase role:** When an element's effective `wam-policy-license` has `requiresAttribution: true`, the User Agent MUST set or verify this attribute as part of the Record phase for any mutation affecting that element. If no citation is available, the User Agent MUST block the mutation and return a structured error rather than recording an uncited mutation on attributed content (§6.5).
*   **Tool:** `wam_inspect_provenance` returns this field as `citation`.

## The WAM-Intent Namespace

The `wam-intent` namespace defines soft constraints and semantic signals that help the User Agent construct a deterministic context for the LLM. Unlike policy attributes, these do not strictly enforce visibility or mutability by default, but provide metadata that can be targeted by policies.

In the Tool Lifecycle Model (§11), intent attributes serve as inputs to the **Configure phase**: they determine which MCP tools are exposed to the LLM and how those tools construct Scoped LLM Calls. Two groups of attributes drive this:

*   **Group A — Scoped Call Configuration** (`wam-intent-category`, `wam-intent-instruction`, `wam-intent-tone`, `wam-intent-output`): These attributes compose the **Scoped Call Configuration Object** (§8.2), which is passed to any mutation tool that makes an internal LLM call on behalf of the element.
*   **Group B — Tool Availability Signals** (`wam-intent-function`, `wam-intent-workflow`): These attributes gate the exposure of the `wam_invoke` tool in `tools/list`. Each recognized value causes a distinct `wam_invoke` variant to be offered to the orchestrating LLM.

Additionally, `wam-intent-importance` controls token-budget priority in `wam_build_context`, and `wam-intent-entity` enriches the Mutable Element Manifest with a canonical entity reference. See §8 for the full normative processing model.

### The wam-intent-category attribute
Assigns a semantic category to a node, allowing it to be targeted by Global Policy rules or specific LLM instructions.

*   **Syntax:** `wam-intent-category="<string>"`
*   **Purpose:** Provides a stable, semantic label (e.g., "quote", "advertisement", "navigation") independent of CSS classes or visual presentation.
*   **Configure phase role (Group A):** Populates the `category` field of the Scoped Call Configuration Object (§8.2). When a mutation tool makes an internal LLM call for this element, the category is used to select the Optimized System Prompt from the Standardized Lexicon.
*   **Tool availability:** Does not gate any specific MCP tool; acts as a routing key for Standardized Lexicon lookup.

### The wam-intent-importance attribute
Specifies the relative priority of the content within the document topology.

*   **Syntax:** `wam-intent-importance="critical|high|normal|low|background"`
*   **Purpose:** Guides the User Agent in prioritizing content for the LLM context. `critical` content MUST be preserved if token limits are reached, while `background` content MAY be discarded.
*   **Configure phase role:** Supplies the `priority` field to `wam_build_context`. The tool MUST order elements in the Mutable Element Manifest by importance: `critical` > `high` > `normal` > `low` > `background`. When token limits require truncation, elements are dropped from the tail of this ordering.
*   **Tool availability:** Does not gate any specific MCP tool.

### The wam-intent-entity attribute
Links the content to a specific real-world entity for disambiguation.

*   **Syntax:** `wam-intent-entity="<URI>"`
*   **Purpose:** Provides a canonical reference (e.g., Wikidata ID, Schema.org URL) to ground the LLM's understanding of named entities.
*   **Configure phase role:** Populates the `intent.entity` field in the element's entry in the Mutable Element Manifest returned by `wam_build_context`. This allows the orchestrating LLM to reason about entity identity before deciding which mutation tool to call.
*   **Tool availability:** Does not gate any specific MCP tool.

### The wam-intent-instruction attribute
Provides explicit, free-form instructions to the LLM for processing the specific node.

*   **Syntax:** `wam-intent-instruction="<string>"`
*   **Purpose:** Allows developers to bypass standard templates and inject custom prompts. This attribute **overrides** the default prompt generation for Category, Function, and Tone, but preserves semantic identity for Policy enforcement.
*   **Configure phase role (Group A):** Populates the `instruction` field of the Scoped Call Configuration Object (§8.2) with the highest precedence. When present, mutation tools MUST use this value directly as the system prompt fragment for any internal LLM call, overriding all other Group A fields.
*   **Tool availability:** Does not gate any specific MCP tool.

### The wam-intent-function attribute
Defines the interactive purpose of an element.

*   **Syntax:** `wam-intent-function="<string>"`
*   **Purpose:** Semantic label for interactive controls (e.g., "search", "submit"). See the Standardized Lexicon for normative terms. Custom values are accepted.
*   **Configure phase role (Group B):** This attribute is a **tool availability signal**. The User Agent MUST expose the `wam_invoke` tool in `tools/list` for this element, with the `action` parameter constrained to the value of this attribute. If the value appears in the Standardized Lexicon, the tool description MUST include the Optimized System Prompt for that action. Multiple space-separated values MAY be specified; each causes a separate `wam_invoke` entry or an `action` enum containing all values.
*   **Note:** `wam_invoke` is only meaningful when `wam-policy-output` permits `interaction`.

### The wam-intent-workflow attribute
Defines the role of an element within a multi-step process.

*   **Syntax:** `wam-intent-workflow="<string>"`
*   **Purpose:** Semantic label for workflow states (e.g., "step", "prerequisite"). See the Standardized Lexicon for normative terms. Custom values are accepted.
*   **Configure phase role (Group B):** Like `wam-intent-function`, this is a **tool availability signal**. The User Agent MUST expose the `wam_invoke` tool with the `stage` parameter constrained to the value of this attribute. Workflow values provide the orchestrating LLM with a process-aware interaction surface, enabling it to call `wam_invoke` with awareness of where this element sits in a multi-step flow.
*   **Note:** `wam_invoke` is only meaningful when `wam-policy-output` permits `interaction`.

### The wam-intent-output attribute
Specifies the desired format for the LLM's response.

*   **Syntax:** `wam-intent-output="<string>"`
*   **Purpose:** Instructions for response shaping (e.g., "json", "concise"). See the Standardized Lexicon for normative terms. Custom values are accepted.
*   **Configure phase role (Group A):** Populates the `output_format` field of the Scoped Call Configuration Object (§8.2). When a mutation tool makes an internal LLM call, the `output_format` is appended to the system prompt to constrain the response structure.
*   **Tool availability:** Does not gate any specific MCP tool.

### The wam-intent-tone attribute
Specifies the desired persona or tone for the LLM's response.

*   **Syntax:** `wam-intent-tone="<string>"`
*   **Purpose:** Instructions for stylistic adaptation (e.g., "formal", "empathetic"). See the Standardized Lexicon for normative terms. Custom values are accepted.
*   **Configure phase role (Group A):** Populates the `tone` field of the Scoped Call Configuration Object (§8.2). When a mutation tool makes an internal LLM call, the `tone` is appended to the system prompt to constrain stylistic output.
*   **Tool availability:** Does not gate any specific MCP tool.

The `wam-policy` namespace defines hard constraints that a conforming User Agent MUST enforce. These are split into three primary attributes to govern the flow of information and mutations.

### The wam-policy-input attribute
Governs the flow of data from the DOM to the Language Model (Visibility). This attribute accepts a **space-separated list** of allowed information channels. The User Agent MUST construct the context using the union of these channels.

*   **`none` (Default):** The node is completely hidden from the LLM.
*   **`structure`:** The LLM may see the element and its attributes (subject to filtering), but not its text content or children.
*   **`text`:** The LLM may see the text content of the node.
*   **`attributes`:** The LLM may see the attributes of the node.
*   **`media`:** The LLM may see media content (images, audio, video).
*   **`all`:** Shorthand for `structure text attributes media`.

**Example:** `wam-policy-input="structure text"` creates a "Masked" view where the structure and text are visible, but attributes (like PII in `data-user-id`) are hidden.

### The wam-policy-output attribute
Governs the flow of mutations from the Language Model to the DOM (Enforcement). This attribute accepts a **space-separated list** of permission tokens. The User Agent MUST grant the union of all permissions specified.

*   **`readonly` (Default):** No mutations are permitted.
*   **`style`:** Grants permission to modify the Presentation Layer (CSS/Classes).
*   **`interaction`:** Grants permission to modify the Interaction Layer (Scripts/Event Handlers/State).
*   **`layout`:** Grants permission to reorder child nodes (formerly `reorder-only`).
*   **`annotation`:** Grants permission to wrap text nodes without changing content.
*   **`content`:** Grants permission to modify the Content Layer (Text).
*   **`data`:** Grants permission to modify Machine-Readable Payloads (Values, Data Attributes).
*   **`append`:** Grants permission to append new children.
*   **`mutable`:** Shorthand for all permissions.

**Example:** `wam-policy-output="style annotation"` allows highlighting and styling but prevents text alteration.

### The wam-policy-memory attribute
Governs the persistence of interaction data (Retention). This attribute accepts a **space-separated list** of allowed storage scopes.

*   **`none` (Default):** Ephemeral processing only.
*   **`session`:** Data may be retained for the duration of the current browsing session.
*   **`user`:** Data may be stored in the user's long-term profile (e.g., "Remember I like dark mode").
*   **`training`:** Data may be used to train or fine-tune the global model.

**Example:** `wam-policy-memory="session user"` allows personalization but prohibits using the data for model training.

# Global Policy

A server MAY provide a global policy via a JSON-encoded payload. This payload defines default behaviors and immutable constraints for the entire document.

## Policy Delivery

The Global Policy MAY be delivered via HTTP response header, HTML meta tag, or both. When multiple sources are present, the User Agent MUST apply **layered precedence** where the HTTP header establishes authoritative constraints and the meta tag can only add further restrictions.

### HTTP Response Header

The server MAY deliver the Global Policy via the `WAM-Policy` HTTP response header.

**Syntax:**

```http
WAM-Policy: <json-policy>
```

**Example:**

```http
HTTP/1.1 200 OK
Content-Type: text/html
WAM-Policy: {"defaults":{"wam-policy-output":["readonly"]},"constraints":{"block-selectors":[".secret"]}}
```

For policies exceeding practical header size limits (~8KB), the server SHOULD use the `WAM-Policy-Src` header to reference an external policy file.

**External Policy Reference:**

```http
WAM-Policy-Src: /.well-known/wam-policy.json
```

The User Agent MUST fetch the referenced policy file before allowing any LLM interaction with the document. The referenced file MUST be same-origin or served with appropriate CORS headers (`Access-Control-Allow-Origin`).

### HTML Meta Tag

The document MAY include a Global Policy via a `<meta>` tag in the `<head>` element.

**Syntax:**

```html
<meta name="wam-policy" content="<json-policy>">
```

**Example:**

```html
<head>
  <meta name="wam-policy" content='{"defaults":{"wam-policy-memory":["none"]}}'>
</head>
```

For external policy files:

```html
<meta name="wam-policy-src" content="/.well-known/wam-policy.json">
```

### Delivery Precedence

When both HTTP header and meta tag provide policy, the User Agent MUST apply the following precedence rules:

1.  **HTTP Header Authority:** The policy delivered via HTTP header (or `WAM-Policy-Src`) establishes the authoritative baseline. This policy is considered **tamper-proof** as it cannot be modified by page scripts.

2.  **Meta Tag Restrictions:** The policy delivered via meta tag is applied as an **additional restriction** using intersection semantics. The meta tag can only make the policy MORE restrictive, never more permissive.

3.  **Intersection Calculation:**
    *   `effective.defaults = header.defaults ∩ meta.defaults`
    *   `effective.constraints = header.constraints ∪ meta.constraints`

**Example (Precedence Resolution):**

```http
WAM-Policy: {"defaults":{"wam-policy-output":["style","content","annotation"]}}
```

```html
<meta name="wam-policy" content='{"defaults":{"wam-policy-output":["style","annotation"]}}'>
```

**Effective Policy:**
```
defaults.wam-policy-output = [style, content, annotation] ∩ [style, annotation]
                           = [style, annotation]
```

The meta tag removed `content` from the allowed outputs, which is permitted. A meta tag attempting to ADD permissions not in the header would have no effect.

### Timing and Blocking

The User Agent MUST resolve the Global Policy before initiating any LLM interaction with the document.

*   **HTTP Header:** Available immediately upon response receipt. Does not block HTML parsing.
*   **External File (via `WAM-Policy-Src` or `wam-policy-src`):** The User Agent MUST fetch and parse the policy file before LLM interaction. This fetch SHOULD be initiated as early as possible (e.g., during HTML preload scanning).
*   **Meta Tag:** Parsed during normal HTML parsing. The User Agent MUST NOT allow LLM interaction with elements that appear before the meta tag until the meta tag is processed.

If the external policy file fails to load (network error, 4xx/5xx response), the User Agent MUST apply **fail-closed** semantics: treat the document as if it had `wam-policy-input="none"` on the root element (no LLM visibility).

### Policy Immutability

Once the Global Policy is resolved (after HTTP headers are received and any external files are fetched), the policy is **immutable** for the lifetime of the document.

*   Page scripts MUST NOT be able to modify the effective Global Policy.
*   Dynamically inserted `<meta name="wam-policy">` tags MUST be ignored.
*   The policy persists across soft navigations (SPA route changes via `pushState`).

For applications requiring per-route policies, the server SHOULD deliver different policies via HTTP header for each route, or the application SHOULD use local DOM attributes (`wam-policy-*`) on route containers.

### Error Handling

If the Global Policy JSON is malformed or fails schema validation:

*   **HTTP Header:** The User Agent MUST apply fail-closed semantics (no LLM visibility) and SHOULD report the error to the developer console.
*   **Meta Tag:** The User Agent MUST ignore the malformed meta tag and continue with the HTTP header policy (if present) or specification defaults.
*   **External File:** The User Agent MUST apply fail-closed semantics if the file is unparseable.

The User Agent SHOULD report policy parsing errors to the `report-to` endpoint if one is configured in a valid portion of the policy.

## JSON Schema

The global policy is defined as a JSON object. This schema enforces site-wide defaults and specific constraints, such as blocking specific selectors or enforcing co-occurrence dependencies (e.g., preventing a quote from appearing without its citation).

```json
{
  "report-to": "https://api.example.com/llm-reports",
  "report-only": true,
  "defaults": {
    "wam-policy-input": ["structure", "text", "attributes", "media"],
    "wam-policy-output": ["readonly"],
    "wam-policy-memory": ["none"]
  },
  "constraints": {
    "block-selectors": ["css-selector", "..."],
    "category-rules": {
      "advertisement": { "wam-policy-input": ["none"] },
      "quote": { "wam-policy-output": ["readonly"] }
    },
    "dependencies": [
      {
        "trigger": ".pull-quote",
        "requires": ".attribution-context",
        "scope": "input",
        "failure-mode": "omit-trigger"
      }
    ]
  }
}
```

### Constraint Types
*   **`block-selectors`:** Forcibly removes elements matching the CSS selector from the LLM's view.
*   **`category-rules`:** Maps an `wam-intent-category` value (e.g., `advertisement`) to specific policy enforcements (e.g., `block`). This allows semantic control over policy without relying on brittle CSS classes.
*   **`dependencies`:** Enforces co-occurrence of elements to maintain context (e.g., requiring a citation for a quote).

### Policy Reporting

The Global Policy Header supports a reporting mechanism to help developers audit compliance and debug policy configurations without breaking functionality.

*   **`report-to` (URI):** Specifies the endpoint where the User Agent SHOULD send violation reports. The reports are sent as JSON payloads containing details about the attempted mutation, the violated policy, and the target element.
*   **`report-only` (Boolean):** If `true`, the User Agent MUST enforce policies in **Audit Mode**. Violations are reported to the `report-to` endpoint, but the mutations themselves are **allowed** to proceed. This is critical for safely rolling out restrictive policies on live sites.

## Precedence and Inheritance

The effective policy for any element is determined by a layered precedence model. At each layer, **intersection semantics** apply: permissions are only granted if ALL applicable layers agree.

### Precedence Layers (Highest to Lowest Authority)

1.  **License Profile:** If `wam-policy-license` specifies an SPDX identifier, the license's implicit constraints take highest precedence. See Section 6.
2.  **Global Policy Constraints:** Constraints from `block-selectors`, `category-rules`, and `dependencies` cannot be overridden by any lower layer.
3.  **Global Policy (HTTP Header):** The policy delivered via HTTP header establishes the authoritative defaults.
4.  **Global Policy (Meta Tag):** Can only restrict (never expand) the HTTP header policy via intersection.
5.  **Shadow DOM Boundary:** If the element is within a shadow tree, inheritance from light DOM requires explicit opt-in. See Section 10.
6.  **Inherited Policy:** Policy inherited from ancestor elements in the DOM tree.
7.  **Local Attributes:** Policy attributes on the element itself (`wam-policy-input`, `wam-policy-output`, `wam-policy-memory`).

### Effective Policy Calculation

For any element, the effective policy is computed as:

```
EffectivePolicy(element) =
    LicenseProfile(element)                    // If wam-policy-license present
  ∩ GlobalConstraints                          // block-selectors, category-rules
  ∩ GlobalDefaults(header ∩ meta)              // Resolved global defaults
  ∩ InheritedPolicy(ancestors)                 // DOM inheritance chain
  ∩ LocalAttributes(element)                   // Element's own attributes
```

### Inheritance Rules

1.  **DOM Inheritance:** Attributes on a node apply to all its descendants unless a descendant specifies its own attribute.
2.  **Shadow Boundary:** Shadow roots block inheritance by default. Components must opt-in via `wam-policy-inherit`.
3.  **Slotted Content:** Subject to intersection of light DOM policy AND slot container policy.
4.  **Constraints Are Absolute:** Global Policy constraints (`block-selectors`, `category-rules`) MUST NOT be overridden by any local attribute or inheritance.

### Conflict Resolution

When computing intersections, the following rules apply:

*   **Token Intersection:** Only tokens present in ALL applicable policies are granted.
*   **Empty Intersection:** If intersection results in an empty set for `wam-policy-output`, the effective policy is `readonly`.
*   **Conflicting Defaults:** If no explicit policy exists at any layer, specification defaults apply (`input=all`, `output=readonly`, `memory=none`).

# Tool Lifecycle Model

This section defines the normative model by which a conforming User Agent mediates all interaction between an LLM and the document. Every LLM action on the document — reading content, applying mutations, invoking controls — MUST occur through a defined **WAM MCP Tool**. The User Agent MUST NOT allow the LLM to observe or modify the document by any other mechanism.

The set of tools offered in any given context is not fixed: it is computed from the document's WAM attributes and the current Global Policy. This computed tool set is the primary enforcement mechanism for WAM policies. An LLM cannot attempt a disallowed mutation if the corresponding tool is absent from the offered tool list.

## 11. The Three-Phase Tool Call

Every WAM MCP tool call passes through three mandatory phases, in order:

1.  **Gate** — The User Agent evaluates whether the tool may be called at all, given the target element's effective policies. If the gate check fails, the tool MUST NOT be executed, and the User Agent MUST return a structured error to the LLM.
2.  **Configure** — The User Agent resolves the tool's runtime behaviour from the element's `wam-intent-*` attributes: which system prompt to use for any scoped LLM call, what response format to request, and what entity context to provide.
3.  **Record** — After successful execution, the User Agent MUST write a Provenance Ledger entry **before** returning the result to the LLM. If ledger entry creation fails, the mutation MUST be rolled back. The live DOM and Provenance Ledger MUST remain consistent at all times (fail-closed).

The three WAM namespaces map directly onto these phases:

| Phase | Namespace | Governs |
| :--- | :--- | :--- |
| Gate | `wam-policy-*` | Which tools are offered; whether a call is permitted |
| Configure | `wam-intent-*` | How the tool behaves when called |
| Record | `wam-provenance-*` | What is written to the Provenance Ledger |

## 12. Tool Taxonomy

WAM MCP tools are divided into four categories based on capability class and gating requirements.

### 12.1. Context Tools (Always Available)

Context tools are offered in every interaction, regardless of element-level policies. They are read-only with respect to the document and generate no Provenance Ledger entries.

| Tool | Description |
| :--- | :--- |
| `wam_build_context` | Returns the policy-filtered context representation of the page, the composed system prompt, and the Mutable Element Manifest (§12.5). |
| `wam_read_element` | Returns the policy-filtered content of a single element, identified by selector. |
| `wam_get_policy` | Returns the computed Effective Permission Set for an element. |
| `wam_list_mutable_elements` | Returns all elements for which at least one mutation tool is currently available. |
| `wam_inspect_provenance` | Returns the Provenance Ledger entries for an element. |

A conforming UA MUST include all five context tools in every `tools/list` response, regardless of page policy.

### 12.2. Mutation Tools (Policy-Gated)

Mutation tools modify the document. Each is unlocked by a specific `wam-policy-output` token on the target element. The User Agent MUST NOT include a mutation tool in the offered tool list unless the target element's Effective Permission Set includes the corresponding token.

| Tool | Required Token | Operation |
| :--- | :--- | :--- |
| `wam_apply_style` | `style` | Modifies `class` and `style` attributes. |
| `wam_set_interaction` | `interaction` | Modifies event handlers, ARIA states, and form state attributes. |
| `wam_reorder_children` | `layout` | Permutes the direct child nodes of an element. |
| `wam_annotate` | `annotation` | Wraps text runs in inline elements without altering text content. |
| `wam_set_content` | `content` | Replaces text node content. |
| `wam_set_data` | `data` | Modifies form values, `data-*` attributes, `<meta>` content, and JSON-LD blocks. |
| `wam_append_child` | `append` | Inserts new child nodes at the end of an element's child list. |

*Note:* The `mutable` token grants all seven mutation tools simultaneously.

Because tool availability is per-element, the same tool may be offered for one element and absent for another within the same interaction turn. The `wam_list_mutable_elements` tool allows the LLM to survey what is mutable before issuing tool calls that would fail.

### 12.3. Interaction Tools (Intent-Gated)

Interaction tools invoke controls on the page. They are gated by `wam-intent-function` values rather than by output policy tokens, and additionally require `interaction` (or `mutable`) in the element's effective output policy.

| Tool | Gate condition | Action |
| :--- | :--- | :--- |
| `wam_invoke` | Element has `wam-intent-function` AND `interaction` ∈ Effective Permission Set | Invokes the control's primary action. The `action` argument mirrors the `wam-intent-function` value (`submit`, `search`, `login`, etc.). |

The User Agent MUST expose `wam_invoke` for every element that satisfies both gate conditions. It MUST NOT expose `wam_invoke` for elements that lack `wam-intent-function`, even if `interaction` is permitted.

### 12.4. Scoped LLM Calls

A **Scoped LLM Call** is a subsidiary LLM invocation made by the User Agent from within a tool's execution. It allows a tool to generate content — a summary, a translation, an annotation — without requiring the orchestrating LLM to read and reproduce the element's full content itself. The orchestrating LLM directs *what* to do; the scoped call executes *how* to do it for a particular element.

Any mutation tool MAY accept an `instruction` argument in lieu of a direct `value` argument. When `instruction` is present and `value` is absent, the User Agent MUST:

1.  Fetch the element's content, applying `wam-policy-input` filtering exactly as `wam_read_element` would.
2.  Resolve the Configure phase for the element, producing a system prompt from its `wam-intent-*` attributes (§I, defined in the Intent Processing section).
3.  Invoke the LLM with: the element's filtered content, the resolved system prompt, and the `instruction` value.
4.  Use the LLM's response as the `value` for the mutation.
5.  Proceed to the Gate and Record phases as normal.

The model used for a scoped call is implementation-defined and MAY differ from the orchestrating model. The Provenance Ledger entry MUST record both the **orchestrating model** (the model that invoked the tool) and the **generating model** (the model whose output became the new value) as distinct fields.

*Note:* Scoped calls are subject to the same input policy as direct reads. A scoped call on an element with `wam-policy-input="none"` MUST be rejected at the Gate phase, since there is no content to pass to the inner LLM.

### 12.5. The Mutable Element Manifest

`wam_build_context` returns, alongside the filtered HTML fragment and composed system prompt, a **Mutable Element Manifest**: a structured enumeration of every element for which at least one mutation tool is currently available.

Each manifest entry MUST include:

*   **`selector`**: A UA-assigned CSS selector that uniquely identifies the element within the current document.
*   **`available_tools`**: The list of mutation and interaction tool names available for this element.
*   **`intent`**: The element's resolved intent metadata: `category`, `importance`, and `entity` if present.
*   **`provenance`**: Any pre-existing provenance metadata on the element: `source`, `citation`, and prior `operations`.

The `wam_id` field (the element's `id` attribute) MUST be included if present.

A conforming UA MUST keep the manifest consistent with the actual offered tool list at all times. A tool MUST NOT appear in the manifest but be absent from `tools/list`, or vice versa.

## 13. Interaction Protocol

### 13.1. Discovery Before Action

A conforming UA MUST structure LLM interaction in two phases:

**Phase 1 — Discovery:** The LLM MUST call `wam_build_context` as its first tool call on any page or after any navigation. Mutation and interaction tools MUST NOT appear in the `tools/list` response prior to a successful `wam_build_context` call in the current page session.

**Phase 2 — Action:** After `wam_build_context` has been called, mutation and interaction tools are added to subsequent `tools/list` responses for elements that permit them. Tool calls in this phase that would violate the effective output policy MUST return a structured error; the User Agent MUST NOT apply partial mutations.

### 13.2. Selector Stability

The UA-assigned selectors in the Mutable Element Manifest and in tool call arguments MUST remain stable for the duration of a single page session. If a dynamic DOM modification invalidates a previously issued selector, the User Agent MUST invalidate the current session and require a new `wam_build_context` call before accepting further mutation tool calls.

### 13.3. Atomicity

Each mutation tool call MUST be atomic with respect to the Provenance Ledger. The User Agent MUST execute steps in the following order, with full rollback on any failure:

1.  Validate gate conditions (Effective Permission Set check).
2.  Execute the mutation in memory (do not yet apply to the live DOM).
3.  Write the Provenance Ledger entry.
4.  Apply the mutation to the live DOM.
5.  Return success to the LLM.

### 13.4. Prompt Injection Hardening

The User Agent MUST treat all tool arguments as untrusted input.

*   **Selector arguments** MUST be validated as syntactically well-formed CSS selectors that resolve to nodes within the current document. Selectors containing characters outside the CSS selector grammar MUST be rejected with an error before the Gate phase is entered.
*   **Value arguments** for mutation tools MUST be sanitised before DOM application. Executable content — `<script>` elements, `javascript:` URL schemes, and event handler attributes (`on*`) — MUST be stripped from any HTML value.
*   **Instruction arguments** for scoped LLM calls MUST be passed to the inner LLM verbatim but MUST NOT be used to override WAM policy attributes. The Effective Permission Set is always resolved from the DOM; LLM-provided instructions cannot elevate permissions.

## 14. Conformance Requirements (Tool Layer)

A **WAM-conforming User Agent** at the tool layer MUST satisfy all of the following:

1.  **Complete context tool set:** Implement and offer all five tools defined in §12.1 in every interaction.
2.  **Mutation tool gating:** Never include a mutation tool in `tools/list` for an element whose Effective Permission Set does not contain the corresponding output token.
3.  **Interaction tool gating:** Expose `wam_invoke` if and only if the element has a `wam-intent-function` attribute and `interaction` ∈ Effective Permission Set.
4.  **Discovery-first:** Withhold mutation and interaction tools until `wam_build_context` has been called in the current page session.
5.  **Atomic mutation with rollback:** Apply the Gate → Execute → Record → Commit sequence for every mutation call, with full rollback on any step failure.
6.  **Manifest consistency:** The Mutable Element Manifest returned by `wam_build_context` MUST exactly match the offered tool list at all times.
7.  **Selector sanitisation:** Reject selector arguments that are syntactically invalid or resolve outside the current document.
8.  **Input policy applied to scoped calls:** Apply `wam-policy-input` filtering to element content before passing it to any scoped LLM call.
9.  **Dual provenance for scoped calls:** Record both the orchestrating and generating model identifiers in Provenance Ledger entries resulting from scoped calls.

# Processing Model

This section defines the normative requirements for User Agents when enforcing mutation policies. The User Agent MUST calculate the **Effective Permission Set** as the union of all tokens present in the `wam-policy-output` attribute.

## 1. The Semantic Payload Principle (Core Constraint)

Regardless of the permission set, the User Agent MUST determine the mutability of any specific attribute or node based on its semantic role. This principle applies within every mutation tool call: even when a tool is offered and its gate conditions are satisfied, individual attributes and nodes within the target element remain subject to these constraints. Token presence exposes a tool; the Semantic Payload Principle constrains what that tool may touch.

*   **Immutable Payload (Identity & Reference):** Attributes defining identity (`id`, `name`), structure (`for`, `headers`), or data source/destination (`src`, `href`, `action`, `data`) are **strictly readonly** unless the `mutable` token is explicitly present.
*   **Mutable State (Presentation & Interaction):** Attributes defining visual style (`class`, `style`) or transient state (`aria-*`, `checked`, `open`) are subject to specific permission tokens.

## 2. Global Policy Resolution (Category Conflicts)

When multiple `wam-intent-category` values apply to a single node, and the Global Policy defines conflicting rules for these categories, the User Agent MUST resolve the conflict using **Intersection Logic** (Restrictive Priority). Because tokens map directly to tools (§3, §12.2), narrowing the Effective Permission Set through intersection also narrows the offered tool list for that element.

*   **Rule:** The effective permission set granted by the Global Policy is the **intersection** of the allowed tokens for each applicable category.
*   **Implication:** If *any* active category rule forbids a specific action (by omitting the corresponding token), that action is forbidden, even if other categories would allow it. The corresponding mutation tool MUST NOT appear in `tools/list` for that element.
*   **Example:**
    *   Category A (`user-content`) allows: `content`, `interaction`.
    *   Category B (`archived`) allows: `readonly` (empty set).
    *   **Result:** `content` AND `interaction` AND `(empty)` = `readonly`. Neither `wam_set_content` nor `wam_set_interaction` is offered for this element.

## 3. Token-Based Enforcement

Each `wam-policy-output` token serves two normative purposes: it causes the corresponding **WAM MCP mutation tool** to appear in the `tools/list` response for that element (the Gate phase, §11), and it defines the exact DOM operations that tool is permitted to perform. The User Agent MUST NOT include a mutation tool unless its corresponding token is present in the Effective Permission Set, and MUST NOT permit the tool to perform any operation not listed for its token below.

See §12.2 for the canonical mapping of tokens to tool names.

### `style` (Presentation Layer)

*   **Exposed tool:** `wam_apply_style`
*   **Allowed:** Modification of `class` and `style` attributes.
*   **Blocked:** Everything else.

### `interaction` (Behavioral Layer)

*   **Exposed tool:** `wam_set_interaction`; also gates `wam_invoke` when `wam-intent-function` is present (§12.3).
*   **Allowed:**
    *   Modification of `class`, `style`.
    *   Modification of Event Handlers (`on*`) and ARIA states (`aria-*`).
    *   Modification of global interaction attributes (`tabindex`, `hidden`, `contenteditable`, `draggable`, `spellcheck`).
    *   Insertion of `<script>` and `<style>` elements.
    *   Modification of Form State (`checked`, `selected`, `disabled`, `readonly`, `open`).
*   **Blocked:** Modification of Text Nodes, Payload Attributes (`src`, `href`, `id`), and Data Values (`value`, `data-*`).

### `layout` (Structural Reordering)

*   **Exposed tool:** `wam_reorder_children`
*   **Allowed:** Reordering (permuting) of direct child nodes.
*   **Blocked:** Modification, addition, or removal of child nodes.

### `annotation` (Non-Destructive Wrapping)

*   **Exposed tool:** `wam_annotate`
*   **Allowed:** Splitting text nodes and wrapping them in inline elements (e.g., `<span>`, `<mark>`, `<a>`).
*   **Constraint:** The concatenated `textContent` of the parent element MUST remain identical.
*   **Blocked:** Changing the text characters themselves.

### `content` (Text Layer)

*   **Exposed tool:** `wam_set_content`; supports both direct `value` and delegated `instruction` arguments (Scoped LLM Call, §12.4).
*   **Allowed:** Modification of Text Nodes.
*   **Blocked:** Changing the DOM structure or attributes of container elements.

### `data` (Machine-Readable Payload)

*   **Exposed tool:** `wam_set_data`; supports both direct `value` and delegated `instruction` arguments (Scoped LLM Call, §12.4).
*   **Allowed:**
    *   **Form Values:** Modification of the `value` attribute on form controls.
    *   **Data Attributes:** Modification of custom `data-*` attributes.
    *   **Meta Content:** Modification of the `content` attribute on `<meta>` tags.
    *   **Data Blocks:** Modification of text content within `<script>` tags that have a data MIME type (e.g., `application/ld+json`, `application/json`) but NOT executable scripts (`text/javascript`).
*   **Blocked:** Modification of Rendered Text Nodes or Document Structure.

### `append` (Additive Structure)

*   **Exposed tool:** `wam_append_child`; supports both direct `value` and delegated `instruction` arguments (Scoped LLM Call, §12.4).
*   **Allowed:** Insertion of new child nodes (elements or text) at the end of the child list.
*   **Blocked:** Modification or removal of existing siblings.

### `mutable` (Full Access)

*   **Exposed tools:** All seven mutation tools simultaneously (`wam_apply_style`, `wam_set_interaction`, `wam_reorder_children`, `wam_annotate`, `wam_set_content`, `wam_set_data`, `wam_append_child`).
*   **Allowed:** All operations. The User Agent removes all output-token restrictions for this node.

## 4. Enforcement of Visibility (`wam-policy-input`)

`wam-policy-input` governs the **Gate phase** (§11) of the Context Tools `wam_build_context` and `wam_read_element` (§12.1). Unlike `wam-policy-output`, visibility tokens do not expose or suppress individual tools — all Context Tools are always offered. Instead, they control what those tools are permitted to return: an element's visibility tokens determine which channels (text, attributes, media) appear in the tool's response.

Additionally, `wam-policy-input` gates **Scoped LLM Calls** (§12.4): the content passed to an inner LLM invocation MUST be filtered by the same rules as `wam_read_element`. An element with `wam-policy-input="none"` MUST be excluded from scoped LLM calls on that element; the User Agent MUST reject such a call at the Gate phase.

The User Agent MUST transform the DOM into a context representation for the LLM by filtering nodes based on the `wam-policy-input` tokens. This section defines the normative requirements for context construction.

### 4.1. Context Representation Format

The context representation is the content returned by `wam_build_context` (in its `html_fragment` field) and by `wam_read_element`. It MUST be an HTML fragment string. The User Agent MAY support additional output formats (plain text, Markdown, accessibility tree) as implementation-defined options, but HTML is the normative default.

**Output Requirements:**

1.  **Well-formed HTML:** The output MUST be a well-formed HTML fragment that could be parsed by a standard HTML parser.
2.  **Encoding:** The output MUST be encoded as UTF-8.
3.  **No Wrapper:** The output MUST NOT include `<!DOCTYPE>`, `<html>`, `<head>`, or `<body>` wrapper elements unless they are part of the filtered content itself.

### 4.2. Visibility Token Processing

The effective visibility for a node is the union of all tokens present in its `wam-policy-input` attribute (after inheritance and constraint resolution). The User Agent MUST process each node according to the following rules:

#### `none` (Omission)
If the effective token set is empty or contains only `none`, the User Agent MUST omit the node and all its descendants from the context representation. The node appears as if it does not exist in the document.

#### `structure` (Element Skeleton)
If `structure` is present:
*   The element's opening and closing tags MUST be preserved.
*   The element's position in the document hierarchy MUST be preserved.
*   Child elements MUST be processed recursively according to their own visibility rules.

If `structure` is present but `text` is NOT:
*   All text node descendants MUST be replaced with the placeholder string `[REDACTED]`.
*   Multiple consecutive text nodes MAY be collapsed into a single placeholder.

#### `text` (Text Content)
If `text` is present:
*   Text nodes MUST be preserved with their content intact.
*   The text content MUST reflect the current DOM state (including any script-driven modifications).

#### `attributes` (Element Attributes)
If `attributes` is present:
*   All attributes on the element MUST be preserved, except as restricted by the Semantic Payload Principle or security filtering (see Section 4.5).

If `structure` is present but `attributes` is NOT:
*   The User Agent MUST strip all attributes except:
    *   `id` (for structural reference)
    *   `class` (for semantic classification)
    *   `role` (for accessibility semantics)
    *   All `llm-*` attributes (for policy and intent metadata)
    *   All `aria-*` attributes (for accessibility state)

#### `media` (Media Content)
If `media` is present:
*   Media-specific attributes MUST be preserved on media elements:
    *   `<img>`: `src`, `srcset`, `alt`, `width`, `height`
    *   `<video>`: `src`, `poster`, `width`, `height`
    *   `<audio>`: `src`
    *   `<source>`: `src`, `srcset`, `type`, `media`
    *   `<picture>`: All child `<source>` elements processed recursively

If `structure` is present but `media` is NOT:
*   Media-specific attributes MUST be replaced with placeholders:
    *   `<img>`: Replace `src` with empty string, set `alt="[image]"` if `alt` was present or add `alt="[image]"` if absent
    *   `<video>`: Replace `src` and `poster` with empty strings, content replaced with `[video content]`
    *   `<audio>`: Replace `src` with empty string, content replaced with `[audio content]`
    *   `<canvas>`: Content replaced with `[canvas graphic]`

#### `all` (Full Visibility)
The token `all` is equivalent to `structure text attributes media`. All content is preserved without redaction.

### 4.3. Whitespace Normalization

The User Agent MUST normalize whitespace in the context representation according to the following rules:

1.  **Collapse Whitespace:** Sequences of whitespace characters (space, tab, newline, carriage return) MUST be collapsed to a single space character, except as noted below.

2.  **Trim Element Boundaries:** Leading whitespace after an opening tag and trailing whitespace before a closing tag MAY be removed for non-inline elements.

3.  **Preserve Preformatted Content:** Whitespace MUST be preserved exactly within:
    *   `<pre>` elements and their descendants
    *   `<code>` elements (unless nested in a context that normalizes)
    *   `<textarea>` element content
    *   Elements with `style="white-space: pre"` or equivalent (if `attributes` token includes style)
    *   Elements with `xml:space="preserve"`

4.  **Script and Style Content:** Whitespace within `<script>` and `<style>` elements MUST be preserved exactly to maintain code validity.

### 4.4. Special Element Handling

The following elements require special processing:

#### Script Elements
`<script>` elements MUST be included in the context representation if their ancestor visibility allows. Scripts are essential for understanding page behavior when the `interaction` output token permits script insertion or modification.

*   **Executable Scripts** (`type="text/javascript"` or no `type`): Include the element and its content.
*   **Data Scripts** (`type="application/json"`, `type="application/ld+json"`, etc.): Include the element and its content. These may be modified via the `data` output token.
*   **Module Scripts** (`type="module"`): Include the element and its content.

#### Style Elements
`<style>` elements MUST be included in the context representation if their ancestor visibility allows. Styles are essential for understanding page presentation when the `style` or `interaction` output tokens permit style modification or insertion.

#### Template Elements
`<template>` elements are inert and MUST be included with their content if visibility allows. The template content represents potential DOM that may be instantiated.

#### Comment Nodes
HTML comments MUST be stripped from the context representation. Comments are not part of the rendered document and may contain implementation notes not intended for LLM consumption.

#### Iframe Elements
`<iframe>` elements MUST be represented as empty placeholder elements: `<iframe src="[cross-origin content]"></iframe>`. The User Agent MUST NOT include cross-origin iframe content in the context representation due to security boundaries.

### 4.5. Security Filtering

Regardless of visibility tokens, the User Agent MUST apply security filtering:

1.  **Event Handler Attributes:** Attributes beginning with `on` (e.g., `onclick`, `onload`) MUST be stripped from the context representation. The LLM can observe that interactive behavior exists via the `interaction` output token, but raw handler code poses injection risks if echoed back.

2.  **JavaScript URLs:** Attribute values beginning with `javascript:` MUST be replaced with `[javascript]`.

3.  **Data URLs:** Large `data:` URLs (exceeding 1024 characters) MAY be truncated with a placeholder indicating the MIME type: `data:image/png;[truncated]`.

### 4.6. Placeholder Format

When content is redacted or replaced, the following placeholder formats MUST be used:

| Context | Placeholder |
|---------|-------------|
| Text content (structure without text) | `[REDACTED]` |
| Image without media token | `alt="[image]"` |
| Video without media token | `[video content]` |
| Audio without media token | `[audio content]` |
| Canvas element | `[canvas graphic]` |
| Cross-origin iframe | `[cross-origin content]` |
| Truncated data URL | `data:<mime>;[truncated]` |
| JavaScript URL | `[javascript]` |

### 4.7. Importance-Based Prioritization

When constructing context for token-limited LLM interactions, the User Agent SHOULD prioritize content based on `wam-intent-importance`:

1.  **`critical`:** MUST be included. If token limits prevent inclusion, the User Agent MUST report an error rather than omit critical content.
2.  **`high`:** SHOULD be included before `normal` content.
3.  **`normal`:** Default prioritization.
4.  **`low`:** MAY be truncated if token limits require.
5.  **`background`:** SHOULD be truncated first if token limits require.

The specific algorithm for token budgeting and truncation is implementation-defined. When truncation occurs, the User Agent SHOULD append `<!-- [content truncated] -->` to indicate incomplete context.

### 4.8. Default Behavior

If no `wam-policy-input` attribute is present on a node and no inherited or global policy applies, the default visibility is `all` (equivalent to `structure text attributes media`), providing full visibility to the LLM.

## 5. Enforcement of Retention (`wam-policy-memory`)

`wam-policy-memory` governs the **Record phase** (§11) across all WAM MCP tool calls: it constrains what any tool may retain after execution completes, whether the tool is a Context Tool reading content or a mutation tool that also received element content for a Scoped LLM Call (§12.4). The retention rules apply to the full content a tool observes, not only to the mutation it produces.

*   **Scoped LLM Calls and memory:** When a mutation tool performs a Scoped LLM Call on an element with `wam-policy-memory="none"`, the User Agent MUST discard the element content passed to the inner LLM and the LLM's response upon completion of the tool call. Neither MAY be written to any persistent store, logged beyond the Provenance Ledger entry, or transmitted to a remote training endpoint.

The User Agent MUST signal and enforce storage limitations based on the `wam-policy-memory` tokens.

*   **`none` (Ephemeral):**
    *   **Signal:** The User Agent MUST send a standard HTTP header (e.g., `Cache-Control: no-store`) or an equivalent signal to the LLM service indicating that the context is ephemeral.
    *   **Storage:** The User Agent MUST NOT persist the interaction content in any persistent storage (e.g., `localStorage`, `IndexedDB`) beyond the lifespan of the request/response cycle.
*   **`session` (Context Window):**
    *   **Signal:** Allows session-scoped context.
    *   **Storage:** The User Agent MAY store the interaction in `sessionStorage` or equivalent ephemeral memory until the browser tab or session is closed.
*   **`user` (Profile):**
    *   **Signal:** Allows long-term user profile updates.
    *   **Storage:** The User Agent MAY persist specific facts or preferences derived from the interaction into the user's long-term profile storage (e.g., `localStorage`, synced settings).
*   **`training` (Model Improvement):**
    *   **Signal:** Explicitly authorizes the use of the interaction data for training or fine-tuning the underlying model.
    *   **Default:** Without this token, the User Agent MUST signal `Do-Not-Train` or equivalent.

**Privacy Default:** If no attribute is present, the default is `none` (Strictly Ephemeral).

## 6. Enforcement of Licensing (`wam-policy-license`)

`wam-policy-license` acts as a ceiling on the Effective Permission Set established by `wam-policy-output`. Because each output token corresponds directly to an exposed mutation tool (§12.2, §3), license restrictions are tool restrictions: reducing the effective token set reduces the offered tool list. The User Agent MUST compute the license-intersected Effective Permission Set **before** populating the `tools/list` response and the Mutable Element Manifest (§12.5), so that tools disallowed by license never appear to the LLM.

The User Agent MUST resolve `wam-policy-license` attributes by expanding the license identifier into a set of implicit policy constraints (a **License Profile**). The effective policy for the node is the **intersection** of the explicitly declared `wam-policy-output` tokens and the License Profile's allowed permissions.

### 6.1. License Profile Structure

A License Profile is a data structure containing the following fields:

| Field | Type | Description |
|-------|------|-------------|
| `spdxIdentifier` | String | The canonical SPDX identifier |
| `allowedOutputTokens` | Sequence&lt;String&gt; | Output tokens permitted by this license |
| `requiresAttribution` | Boolean | Whether the license requires attribution |
| `isCopyleft` | Boolean | Whether the license has copyleft/viral requirements |
| `licenseName` | String? | Human-readable name of the license |
| `commercialUse` | Boolean | Whether commercial use is permitted |
| `shareAlike` | Boolean | Whether derivatives must use the same license |

### 6.2. License Compatibility Matrix (Normative)

The User Agent MUST support the following SPDX identifiers with their associated profiles. This matrix defines the **normative** behavior for license enforcement.

#### 6.2.1. Public Domain and Permissive Licenses

These licenses impose minimal or no restrictions on LLM modifications.

| SPDX Identifier | Allowed Tokens | Attribution | Copyleft | Commercial |
|-----------------|----------------|-------------|----------|------------|
| `CC0-1.0` | `mutable` | No | No | Yes |
| `Unlicense` | `mutable` | No | No | Yes |
| `WTFPL` | `mutable` | No | No | Yes |
| `MIT` | `mutable` | Yes | No | Yes |
| `MIT-0` | `mutable` | No | No | Yes |
| `ISC` | `mutable` | Yes | No | Yes |
| `BSD-2-Clause` | `mutable` | Yes | No | Yes |
| `BSD-3-Clause` | `mutable` | Yes | No | Yes |
| `Apache-2.0` | `mutable` | Yes | No | Yes |
| `Zlib` | `mutable` | Yes | No | Yes |

#### 6.2.2. Creative Commons Licenses

Creative Commons licenses have specific conditions that map to output token restrictions.

| SPDX Identifier | Allowed Tokens | Attribution | Copyleft | Commercial | Notes |
|-----------------|----------------|-------------|----------|------------|-------|
| `CC-BY-4.0` | `mutable` | Yes | No | Yes | Derivatives allowed |
| `CC-BY-3.0` | `mutable` | Yes | No | Yes | Legacy version |
| `CC-BY-SA-4.0` | `mutable` | Yes | Yes | Yes | ShareAlike requirement |
| `CC-BY-SA-3.0` | `mutable` | Yes | Yes | Yes | Legacy ShareAlike |
| `CC-BY-NC-4.0` | `mutable` | Yes | No | No | Non-commercial only |
| `CC-BY-NC-3.0` | `mutable` | Yes | No | No | Legacy NC |
| `CC-BY-NC-SA-4.0` | `mutable` | Yes | Yes | No | NC + ShareAlike |
| `CC-BY-ND-4.0` | `readonly`, `annotation` | Yes | No | Yes | **No derivatives** |
| `CC-BY-ND-3.0` | `readonly`, `annotation` | Yes | No | Yes | Legacy ND |
| `CC-BY-NC-ND-4.0` | `readonly`, `annotation` | Yes | No | No | NC + ND |
| `CC-BY-NC-ND-3.0` | `readonly`, `annotation` | Yes | No | No | Legacy NC-ND |

**No Derivatives (ND) Constraint:** For ND licenses, the User Agent MUST restrict output tokens to `readonly` and `annotation` only. The `annotation` token is permitted because it wraps content without modifying the underlying text.

#### 6.2.3. Copyleft Licenses

Copyleft licenses allow modifications but require derivatives to carry compatible licenses.

| SPDX Identifier | Allowed Tokens | Attribution | Copyleft | Commercial | Notes |
|-----------------|----------------|-------------|----------|------------|-------|
| `GPL-2.0-only` | `mutable` | Yes | Yes | Yes | Strong copyleft |
| `GPL-2.0-or-later` | `mutable` | Yes | Yes | Yes | GPL 2+ |
| `GPL-3.0-only` | `mutable` | Yes | Yes | Yes | Strong copyleft |
| `GPL-3.0-or-later` | `mutable` | Yes | Yes | Yes | GPL 3+ |
| `LGPL-2.1-only` | `mutable` | Yes | Yes | Yes | Weak copyleft |
| `LGPL-2.1-or-later` | `mutable` | Yes | Yes | Yes | LGPL 2.1+ |
| `LGPL-3.0-only` | `mutable` | Yes | Yes | Yes | Weak copyleft |
| `LGPL-3.0-or-later` | `mutable` | Yes | Yes | Yes | LGPL 3+ |
| `AGPL-3.0-only` | `mutable` | Yes | Yes | Yes | Network copyleft |
| `AGPL-3.0-or-later` | `mutable` | Yes | Yes | Yes | AGPL 3+ |
| `MPL-2.0` | `mutable` | Yes | Yes | Yes | File-level copyleft |
| `EPL-2.0` | `mutable` | Yes | Yes | Yes | Eclipse copyleft |
| `EUPL-1.2` | `mutable` | Yes | Yes | Yes | EU copyleft |

**Copyleft Constraint:** When `isCopyleft` is true, the User Agent MUST ensure that any LLM-generated content derived from this node is marked with a compatible license in `wam-provenance-operation` entries. The User Agent MAY prevent insertion of copyleft content into contexts marked as proprietary or incompatibly licensed.

#### 6.2.4. Proprietary and Restricted Licenses

These identifiers indicate content that MUST NOT be modified or may have special restrictions.

| SPDX Identifier | Allowed Tokens | Attribution | Copyleft | Commercial | Notes |
|-----------------|----------------|-------------|----------|------------|-------|
| `proprietary` | `readonly` | N/A | N/A | N/A | No modifications |
| `all-rights-reserved` | `readonly` | N/A | N/A | N/A | Traditional copyright |
| `LicenseRef-*` | (varies) | (varies) | (varies) | (varies) | Custom license reference |

**Proprietary Content:** Content marked with `proprietary` or `all-rights-reserved` MUST be treated as `readonly` only. The User Agent MUST NOT permit any output tokens beyond `readonly`.

### 6.3. License Expression Syntax

The User Agent MUST support SPDX License Expression syntax for compound licenses:

*   **`AND` (Conjunction):** Both licenses apply. The effective profile is the **intersection** of allowed tokens from both licenses.
    *   Example: `MIT AND CC-BY-4.0` → `mutable` (both allow), `requiresAttribution: true` (either requires)
*   **`OR` (Disjunction):** Either license may apply. The effective profile is the **union** of allowed tokens from both licenses.
    *   Example: `GPL-3.0-only OR MIT` → `mutable`, User Agent MAY choose the less restrictive option.
*   **`WITH` (Exception):** Adds an exception to a license. The User Agent SHOULD resolve known exceptions.
    *   Example: `GPL-2.0-only WITH Classpath-exception-2.0`

**Parentheses:** The User Agent MUST support parentheses for grouping: `(MIT OR Apache-2.0) AND CC-BY-4.0`.

### 6.4. Unknown License Handling

When the User Agent encounters an SPDX identifier not in its supported list:

1.  **Conservative Default:** The User Agent MUST treat unknown licenses as `readonly` only (most restrictive).
2.  **Attribution Assumed:** The User Agent MUST assume `requiresAttribution: true`.
3.  **Warning:** The User Agent SHOULD emit a warning indicating the license is unrecognized.
4.  **Fallback Override:** Authors MAY provide explicit `wam-policy-output` tokens, but the conservative default still applies via intersection.

### 6.5. Attribution Enforcement

When a License Profile has `requiresAttribution: true`:

1.  **Provenance Citation Required:** Any LLM mutation on this node MUST include a `wam-provenance-citation` attribute or entry linking to the original source.
2.  **Inherited Requirement:** If a child element is modified, the attribution requirement propagates from the licensed ancestor.
3.  **Validation:** The User Agent MUST validate that mutations include proper attribution; violations SHOULD be reported.

### 6.6. Commercial Use Restrictions

When a License Profile has `commercialUse: false` (e.g., CC-BY-NC variants):

1.  **Context Signal:** The User Agent MUST signal to the LLM that this content is non-commercial only.
2.  **Output Restriction:** The User Agent SHOULD prevent insertion of NC-licensed content into contexts identified as commercial.
3.  **Implementation Note:** Detection of "commercial context" is implementation-defined but MAY include signals from the embedding page or user configuration.

### 6.7. Conflict Resolution

If an explicit `wam-policy-output` attribute conflicts with the License Profile:

1.  **License Takes Precedence:** The effective output tokens are the **intersection** of the explicit tokens and the License Profile's allowed tokens.
2.  **Example:** `wam-policy-output="mutable"` with `wam-policy-license="CC-BY-ND-4.0"` results in effective tokens of `readonly`, `annotation` (the ND license restricts to these).
3.  **Warning:** The User Agent MAY emit a warning when an explicit attribute is overridden by license constraints.
4.  **No Expansion:** An explicit attribute cannot grant permissions beyond what the license allows.

### 6.8. License Inheritance

License constraints inherit to descendants unless overridden:

1.  **Downward Propagation:** A `wam-policy-license` attribute applies to all descendants of the element.
2.  **Local Override:** A descendant MAY specify a different `wam-policy-license`, which applies to that subtree.
3.  **Restriction Only:** A descendant's license can only further restrict, not expand, permissions (intersection with ancestor license).
4.  **Mixed Content:** When content from multiple license sources is combined, the most restrictive license applies to the combined output.

## 7. Dependency Resolution (Global Policy)

When constructing the LLM context, the User Agent MUST enforce dependency constraints defined in the Global Policy Header.

1.  **Dependency Graph Construction:** The User Agent identifies all nodes selected for inclusion in the context (Candidate Set).
2.  **Constraint Check:** For each node in the Candidate Set, the User Agent checks if it matches any `trigger` selector defined in the Global Policy's `dependencies` list.
3.  **Requirement Verification:**
    *   If a node matches a `trigger`, the User Agent MUST verify that at least one node matching the `requires` selector is also present in the Candidate Set.
4.  **Failure Resolution:**
    *   If the Requirement Verification fails, the User Agent applies the `failure-mode`:
        *   **`omit-trigger` (Default):** The triggering node is **removed** from the Candidate Set. The User Agent then re-evaluates dependency constraints recursively.
        *   **`error`:** The context construction process is halted, and the User Agent reports a dependency violation error.

## 8. Intent Attribute Processing (Configure Phase)

This section defines how the User Agent translates `wam-intent` attributes into MCP tool exposure and Scoped LLM Call configuration. Intent attributes serve as inputs to the **Configure phase** of the Tool Lifecycle Model (§11) and have two distinct processing roles.

### 8.1. Two Roles of Intent Attributes

Intent attributes are divided into two functional groups based on how they affect MCP tool behavior:

**Group A — Scoped Call Configuration:** Attributes that configure the subsidiary LLM call made internally by a mutation tool when the orchestrating LLM passes `instruction` rather than `value` to that tool. The Group A attributes (`wam-intent-category`, `wam-intent-instruction`, `wam-intent-tone`, `wam-intent-output`) are resolved into a **Scoped Call Configuration Object** (§8.2) at context-build time and included in the element's Mutable Element Manifest entry.

**Group B — Tool Availability Signals:** Attributes that gate whether `wam_invoke` appears in `tools/list` for this element. The Group B attributes (`wam-intent-function`, `wam-intent-workflow`) cause the User Agent to expose `wam_invoke` with parameter constraints that reflect the declared interactive semantics. If neither attribute is present, `wam_invoke` MUST NOT be listed for the element. See §8.5 for the normative rules.

Additionally, `wam-intent-importance` governs token-budget ordering in `wam_build_context` (§8.6), and `wam-intent-entity` enriches the Mutable Element Manifest (§8.6).

### 8.2. Scoped Call Configuration Object

The User Agent MUST resolve the Group A attributes for each element into a Scoped Call Configuration Object at the time `wam_build_context` is called. This object is embedded in the element's Mutable Element Manifest entry and is passed to any mutation tool that makes an internal (scoped) LLM call.

The object has the following fields:

| Field | Source Attribute | Notes |
|-------|-----------------|-------|
| `instruction` | `wam-intent-instruction` | Highest precedence; if present, overrides all other fields for prompt assembly |
| `category` | `wam-intent-category` | Used for Standardized Lexicon lookup when `instruction` is absent |
| `tone` | `wam-intent-tone` | Appended to the scoped system prompt |
| `output_format` | `wam-intent-output` | Appended to constrain response structure |

When a mutation tool receives an `instruction` parameter from the orchestrating LLM (instead of a direct `value`), it MUST:

1.  Fetch the element's content, subject to input policy (§4).
2.  Assemble a scoped system prompt using the Scoped Call Configuration Object according to the instruction resolution rules (§8.3).
3.  Call the LLM internally with the scoped prompt and the element's content.
4.  Use the LLM's response as the mutation value.
5.  Record dual provenance: the orchestrating model ID and the generating model ID (§9, §14).

### 8.3. Instruction Resolution

Within a scoped LLM call, the User Agent MUST assemble the system prompt fragment for the element using the following precedence:

1.  **`instruction` field (Highest):** If the Scoped Call Configuration Object contains a non-empty `instruction` field, use it verbatim as the primary system prompt fragment. All other fields are still appended after it.
    *   *Note:* The `category` and other semantic values are preserved in the manifest even when overridden, so the orchestrating LLM retains full context.
2.  **Standardized Lexicon (Optimized):** If the `category` field matches a term in the Standardized Intent Lexicon, use the corresponding **Optimized System Prompt** for that category.
3.  **Fallback Template (§8.4):** If neither of the above applies, construct the instruction from the fallback template for the relevant attribute type.

After the primary instruction is determined, `tone` and `output_format` fragments are appended unconditionally if present.

### 8.4. Fallback Templates

For custom values not in the Standardized Lexicon, the User Agent MUST use the following templates to assemble the scoped system prompt fragment:

*   **Category:** `"Treat the following content as a(n) [value]."`
*   **Tone:** `"Adopt a(n) [value] tone."`
*   **Output format:** `"Format your response as [value]."`

### 8.5. Group B — Tool Availability Rules (wam_invoke Gating)

The `wam_invoke` tool MUST be included in `tools/list` for an element if and only if at least one of `wam-intent-function` or `wam-intent-workflow` is present and the element's effective output policy permits `interaction` (§3).

**Function gating (`wam-intent-function`):**

*   The User Agent MUST expose `wam_invoke` with an `action` parameter.
*   If the attribute value is in the Standardized Lexicon, the `action` parameter description MUST include the Optimized System Prompt for that action.
*   If multiple space-separated values are present, the `action` parameter MUST be an enum containing all values.
*   Custom values produce an unrestricted `action` parameter with the fallback template: `"Use this control to [value]."`

**Workflow gating (`wam-intent-workflow`):**

*   The User Agent MUST expose `wam_invoke` with a `stage` parameter.
*   The `stage` parameter description MUST include the workflow role: `"(Workflow Stage: [value])"`.
*   If both `wam-intent-function` and `wam-intent-workflow` are present, `wam_invoke` MUST accept both `action` and `stage` parameters.

**Interaction policy constraint:** If the element's effective output policy does not include `interaction`, the User Agent MUST NOT expose `wam_invoke`, regardless of the presence of Group B attributes. This takes precedence over all Group B rules.

### 8.6. Manifest Integration (importance and entity)

The `wam-intent-importance` and `wam-intent-entity` attributes are processed during `wam_build_context` and populate the Mutable Element Manifest directly.

**Importance — token-budget ordering:**

The User Agent MUST order elements in the Mutable Element Manifest by importance level, with the following hierarchy (highest priority first):

1.  `critical` — MUST be included even if token limits are reached; MAY truncate element content but MUST NOT omit the entry.
2.  `high` — SHOULD be included before `normal` entries.
3.  `normal` (default) — included in standard ordering.
4.  `low` — included if token budget permits; MAY be omitted.
5.  `background` — included only if token budget is unconstrained; MUST be omitted first when truncating.

When elements are omitted due to token limits, the User Agent MUST include a truncation notice in the manifest indicating how many elements were omitted and at which importance levels.

The `importance` level also maps to hint text appended to the element's manifest entry for the orchestrating LLM:

*   **`critical`:** `"Pay maximum attention to this element. It is essential for the user's task."`
*   **`high`:** `"Prioritize this element."`
*   **`normal`:** (No hint appended.)
*   **`low`:** `"This element is supplementary. You may skip it if context is limited."`
*   **`background`:** `"This is background information only. Do not focus on it unless explicitly asked."`

**Entity — manifest enrichment:**

If `wam-intent-entity` is present, the User Agent MUST populate the `intent.entity` field of the element's manifest entry with the URI value. This canonical entity reference allows the orchestrating LLM to reason about entity identity and to de-duplicate or correlate content across elements before deciding which mutation tool to invoke.

## 9. Provenance Processing Model (Record Phase)

The Record phase (§11) executes after every successful mutation tool call. The User Agent functions as the **Authority** on provenance: it writes the Provenance Ledger entry, updates the DOM's `wam-provenance-operation` attribute, and enforces the correlation between them. Authors and page scripts MUST NOT be able to suppress, reorder, or forge this sequence. This section defines the normative requirements for executing the Record phase, maintaining ledger integrity, and surfacing provenance data through MCP tools and the user interface.

### 9.1. Record Phase Execution Sequence

Every successful mutation tool call MUST trigger the Record phase immediately upon completion of the mutation. The User Agent MUST execute the following steps atomically, exactly in this order, with full rollback on any failure (see also §13.3):

1.  **Determine layer token:** Map the completed operation to its layer token using the Layer Token Mapping table below.
2.  **Determine explanation:** Use the `explanation` field from the tool call if provided; otherwise construct a default from the operation type and element role.
3.  **Write Provenance Ledger entry:** Create a new ledger entry (schema §9.2) and append it to the internal Provenance Ledger.
4.  **Append to DOM attribute:** Append `<layer>:<explanation>` to the target element's `wam-provenance-operation` attribute, space-separated from any existing tokens.
5.  **Return result to LLM:** Only after steps 1–4 complete successfully, return the tool result to the orchestrating LLM.

If step 3 or step 4 fails, the User Agent MUST roll back the DOM mutation applied in the tool's execution phase and return a structured error to the LLM. The live DOM and Provenance Ledger MUST remain consistent at all times (fail-closed).

*   **Format:** The appended token MUST follow the syntax `<layer>:<explanation>`.
*   **Layer Alignment:** The `<layer>` token MUST match the type of mutation performed (e.g., `content` for text changes, `style` for class changes).
*   **Explanation:** The `<explanation>` SHOULD be a concise, hyphenated rationale generated by the Agent (e.g., `summarized-text`, `corrected-fact`).

#### Layer Token Mapping

| Mutation Type | Layer Token | Examples |
|--------------|-------------|----------|
| Text node content | `content` | Rewriting text, summarizing, correcting |
| `class` or `style` attribute | `style` | Adding highlight class, changing colors |
| Event handlers, ARIA, form state | `interaction` | Adding onclick, changing aria-expanded |
| Child node reordering | `topology` | Sorting list items, reordering sections |
| `data-*` attributes, form values | `data` | Updating data attributes, form autofill |
| `wam-intent-*` attributes | `intent` | Modifying semantic hints |

#### Explanation Format

The explanation component MUST be a hyphenated string of lowercase ASCII letters and numbers. It SHOULD describe the rationale for the change, not the change itself.

**Valid examples:** `summarized-text`, `corrected-spelling`, `user-requested`, `auto-translated`, `fact-checked-false`

**Invalid examples:** `changed the text`, `MODIFIED`, `update_1`

### 9.2. Provenance Ledger Structure

The User Agent MUST maintain an internal **Provenance Ledger** that records all LLM-initiated mutations. This ledger is separate from (but correlated with) the `wam-provenance-operation` attribute. It is the authoritative record and the primary data source for `wam_inspect_provenance`.

#### Ledger Entry Structure

Each ledger entry MUST contain:

| Field | Type | Description |
|-------|------|-------------|
| `id` | String | Unique identifier for this entry |
| `timestamp` | DOMHighResTimeStamp | When the mutation occurred |
| `target` | Element reference | The element that was modified |
| `layer` | LLMProvenanceLayer | The type of mutation |
| `explanation` | String | The hyphenated rationale |
| `originalValue` | Any | Snapshot of the value before mutation |
| `newValue` | Any | The value after mutation |
| `hasAttributeEntry` | Boolean | Whether a corresponding `wam-provenance-operation` entry exists |
| `orchestratingModelId` | String | Identifier of the LLM that issued the mutation tool call |
| `generatingModelId` | String? | Identifier of the LLM whose output became the new value; only populated when the mutation resulted from a Scoped LLM Call (§12.4) and the generating model differs from the orchestrating model |
| `scopedCall` | Boolean | `true` if this entry resulted from a Scoped LLM Call; `false` for direct-value mutations |

**Dual Model ID Requirement:** When `scopedCall` is `true`, both `orchestratingModelId` and `generatingModelId` MUST be populated. The conformance requirement §14.9 mandates this for all scoped call entries.

#### Original Value Snapshots

The `originalValue` field MUST capture sufficient information to reconstruct the pre-mutation state:

| Layer | Original Value Content |
|-------|----------------------|
| `content` | The text content string before modification |
| `style` | Object with `class` and `style` attribute values |
| `interaction` | Object with relevant attribute values (`aria-*`, `on*`, form state) |
| `topology` | Ordered array of child node references or identifiers |
| `data` | Object with `data-*` attribute values and form `value` |
| `intent` | Object with `wam-intent-*` attribute values |

### 9.3. Baseline Snapshot

The User Agent MUST capture a **Baseline Snapshot** of the DOM at a defined point in time. This baseline serves as the reference for detecting unauthorized mutations.

#### Snapshot Timing

The baseline snapshot MUST be captured:

1.  **Initial Load:** After the document has finished parsing (`DOMContentLoaded`) and the Global Policy has been resolved.
2.  **After Server Updates:** After any server-initiated DOM update (e.g., via `innerHTML` assignment from fetch response, server-sent events, WebSocket messages) that is explicitly marked as authoritative.

The User Agent MUST NOT capture a new baseline after LLM-initiated mutations; those are tracked as deltas from the existing baseline.

#### Snapshot Content

For each element in the document, the baseline snapshot MUST record:

*   **Text Content:** The `textContent` of all text nodes.
*   **Attributes:** All attribute name-value pairs.
*   **Child Order:** The ordered list of child element identifiers.
*   **Tree Position:** The element's position in the DOM tree.

The snapshot MAY be stored as a serialized representation, a hash-based diff structure, or a copy-on-write mechanism—the specific implementation is User Agent-defined.

#### Snapshot Scope

The baseline snapshot MUST cover:

*   All elements in the light DOM.
*   Shadow DOM content for shadow roots with `wam-provenance-transparent` (see Section 10.7).
*   Aggregated mutation tracking for other shadow roots.

### 9.4. Mutation Detection

The User Agent MUST detect DOM mutations that could indicate LLM-initiated changes. The detection mechanism MUST NOT rely solely on the LLM reporting its changes; the User Agent independently verifies.

#### Detection Mechanism

The User Agent SHOULD use MutationObserver or an equivalent mechanism to observe:

*   `childList` mutations (node insertion, removal, reordering)
*   `characterData` mutations (text content changes)
*   `attributes` mutations (attribute changes)
*   `subtree` for recursive observation

#### Attribution

When a mutation is detected, the User Agent MUST determine whether it was:

1.  **LLM-Initiated:** The mutation occurred as a result of LLM agent action. These MUST be logged to the ledger.
2.  **User-Initiated:** The mutation occurred as a result of direct user action (typing, clicking). These SHOULD NOT be logged to the LLM provenance ledger.
3.  **Script-Initiated:** The mutation occurred from page JavaScript not related to LLM. These SHOULD NOT be logged to the LLM provenance ledger.

The User Agent MAY use call stack inspection, explicit API markers, or isolated execution contexts to attribute mutations.

### 9.5. Integrity Validation

The User Agent MUST periodically validate that the Provenance Ledger accurately reflects all LLM-initiated mutations.

#### Validation Triggers

Integrity validation MUST occur:

1.  **On Mutation:** After each LLM-initiated mutation is recorded.
2.  **On Read:** Before returning provenance information via `wamProvenance` or `wamProvenanceLedger` APIs.
3.  **Periodically:** At User Agent-defined intervals during active LLM sessions.
4.  **On Navigation:** Before the document is unloaded or navigated away.

#### Validation Algorithm

For each element with LLM-initiated modifications:

1.  **Compare Current State:** Compare the element's current state to its baseline snapshot.
2.  **Identify Layers:** Determine which layers have been modified (content, style, interaction, topology, data, intent).
3.  **Check Ledger:** For each modified layer, verify that a corresponding ledger entry exists.
4.  **Check Attribute:** For each ledger entry, verify that a corresponding `wam-provenance-operation` token exists on the element.
5.  **Flag Violations:** Any mismatch constitutes an integrity violation.

#### Integrity Violation Types

| Violation Type | Description |
|----------------|-------------|
| `missing-ledger-entry` | DOM was modified but no ledger entry exists |
| `missing-attribute-entry` | Ledger entry exists but `wam-provenance-operation` lacks corresponding token |
| `layer-mismatch` | Ledger entry layer does not match the type of detected mutation |
| `orphaned-entry` | Ledger entry exists but no corresponding DOM change detected |
| `tampered-attribute` | `wam-provenance-operation` attribute was modified without corresponding ledger entry |

### 9.6. Violation Response

When an integrity violation is detected, the User Agent MUST respond according to the violation severity and user preferences.

#### Response Actions

The User Agent MAY implement any combination of:

1.  **Flag:** Mark the element with a visual indicator (e.g., colored border, icon) to alert the user.
2.  **Warn:** Display a non-blocking warning in the UI or console.
3.  **Block:** Prevent the modified content from being rendered until user acknowledgment.
4.  **Revert:** Restore the element to its baseline state.
5. **Report:** Send a violation report to the Global Policy's `report-to` endpoint.

#### Revert Algorithm

If the User Agent implements reversion:

1.  Retrieve the `originalValue` from the ledger entry (if available) or baseline snapshot.
2.  Apply the original value to the element:
    *   For `content`: Set `textContent` to original.
    *   For `style`: Restore `class` and `style` attributes.
    *   For `topology`: Reorder children to original sequence.
    *   For `data`: Restore `data-*` attributes and form values.
    *   For `interaction`: Restore event handlers and ARIA states.
3.  Remove the invalid ledger entry.
4.  Update `wam-provenance-operation` attribute to remove the invalid token.
5.  Fire an `llmintegrityviolation` event with `reverted: true`.

#### User Preferences

The User Agent SHOULD allow users to configure violation response behavior:

*   **Strict Mode:** Block or revert all violations automatically.
*   **Permissive Mode:** Flag and warn only; allow content to render.
*   **Report-Only Mode:** Log violations but take no visible action (for debugging).

### 9.7. Ledger Lifecycle

#### Persistence

The Provenance Ledger MUST persist for the lifetime of the document. The ledger MUST NOT be persisted across page loads unless explicitly authorized by `wam-policy-memory="session"` or `wam-policy-memory="user"`.

If memory retention is authorized:

*   **`session`:** The ledger MAY be serialized to `sessionStorage` and restored on back/forward navigation.
*   **`user`:** The ledger MAY be persisted to long-term storage for audit purposes.

#### Memory Management

For long-running pages with many mutations, the User Agent MAY implement ledger compaction:

1.  **Merge Entries:** Multiple mutations to the same element and layer MAY be merged, preserving only the original `originalValue` and the final `newValue`.
2.  **Prune Reverted:** Entries for reverted mutations MAY be removed.
3.  **Archive Old:** Entries older than a User Agent-defined threshold MAY be archived to compressed storage.

The User Agent MUST NOT discard entries that have not been validated or that represent unacknowledged violations.

### 9.8. Mandatory User Inspection

To ensure conspicuous disclosure without cluttering the UI, the User Agent MUST provide a mechanism for the user to inspect the raw provenance data for any element.

#### MCP Interface

The `wam_inspect_provenance` tool (§12.1) is the normative programmatic interface to the Provenance Ledger. It returns the same information that the user-facing inspection UI must display. A conforming UA MUST ensure that the MCP tool and the UI surface identical data: if a ledger entry is visible in `wam_inspect_provenance` output, it MUST also be visible in the user-facing inspection view for that element, and vice versa.

#### User-Facing Inspection Mechanism

The User Agent MUST implement at least one of:

*   **Context Menu:** A context menu item (e.g., "Inspect LLM Provenance") on right-click.
*   **Trust Panel:** A dedicated panel or sidebar showing provenance for the current page.
*   **Developer Tools:** A tab or section in the browser's developer tools.
*   **Keyboard Shortcut:** A keyboard command to inspect the focused element's provenance.

#### Disclosed Information

The inspection view MUST display:

*   **Source:** The `wam-provenance-source` URI, if present.
*   **Confidence:** The `wam-provenance-confidence` score, if present.
*   **Operations:** The complete `wam-provenance-operation` history as a parsed list.
*   **Ledger Entries:** All ledger entries associated with the element, including timestamps, original/new values, `orchestratingModelId`, and `generatingModelId` where applicable.
*   **Scoped Call Indicator:** For entries where `scopedCall` is `true`, the inspection view MUST clearly indicate that a subsidiary LLM call generated the value, and MUST display both model identifiers.
*   **Integrity Status:** Whether the element has any integrity violations.

#### Visual Indicators

The User Agent SHOULD provide optional visual indicators for LLM-modified content:

*   **Modified Indicator:** A subtle visual cue (icon, underline, background) on elements with `wam-provenance-operation` entries.
*   **Confidence Indicator:** Color-coded indicator based on `wam-provenance-confidence` (green for ≥ 0.8, yellow for 0.5–0.8, red for < 0.5).
*   **Scoped Call Indicator:** A distinct icon or badge on elements where any ledger entry has `scopedCall: true`, signalling that the value was generated by a subsidiary LLM call rather than the orchestrating model directly.
*   **Violation Indicator:** Prominent visual cue for elements with integrity violations.

These indicators SHOULD be user-configurable (on, off, or hover-to-reveal).

### 9.9. Provenance Events

The User Agent MUST fire DOM events to allow pages to observe provenance changes and integrity violations. These events are the DOM-observable counterpart to the MCP tools `wam_inspect_provenance` and `wam_report_violation`: the same Record phase execution that triggers a ledger write and `wam-provenance-operation` append MUST also fire `llmprovenancechange` on the target element. Pages MAY listen to these events for custom logging or UI updates, but MUST NOT be able to suppress or modify integrity violation detection.

#### `llmprovenancechange` Event

Fired at the end of the Record phase execution sequence (§9.1), after the Provenance Ledger entry has been written and the `wam-provenance-operation` attribute has been updated.

```webidl
interface LLMProvenanceChangeEvent : Event {
  readonly attribute Element target;
  readonly attribute LLMProvenanceLayer layer;
  readonly attribute DOMString explanation;
  readonly attribute DOMHighResTimeStamp timestamp;
};
```

#### `llmintegrityviolation` Event

Fired when an integrity violation is detected (§9.5). The `wam_report_violation` MCP tool (§12.1) is the programmatic equivalent: when the orchestrating LLM calls `wam_report_violation`, the User Agent MUST treat it as equivalent to a self-detected violation and fire this event with the same semantics. The LLM cannot suppress the event by not calling the tool; integrity detection is always UA-driven.

```webidl
interface LLMIntegrityViolationEvent : Event {
  readonly attribute Element target;
  readonly attribute LLMProvenanceLayer layer;
  readonly attribute DOMString violationType;
  readonly attribute any originalValue;
  readonly attribute any currentValue;
  readonly attribute boolean reverted;
};
```

Pages MAY listen to these events for custom logging, analytics, or UI updates. Pages MUST NOT be able to suppress or modify integrity violation detection.

## 10. Shadow DOM Policy Boundaries

This section defines how Web Agent Markup policies interact with Shadow DOM encapsulation boundaries. The guiding principle is that **component authors have precedence** over page authors for content within their shadow trees, while **intersection semantics** ensure that permissions are only granted when both parties agree.

### 10.1. Core Principles

1.  **Component Author Precedence:** The author of a shadow root (component author) has final authority over policy decisions within that shadow tree. Page authors cannot override component policies.
2.  **Opt-Out Default:** Shadow roots constitute policy boundaries. By default, policies from the light DOM do NOT cross into shadow trees.
3.  **Opt-In Inheritance:** Component authors MAY explicitly opt into inheriting policies from the host element's context.
4.  **Intersection Semantics:** When inheritance is enabled, the effective policy is the intersection of inherited and local policies. Both component author and page author must agree for a permission to be granted.

### 10.2. Shadow Root as Policy Boundary

A shadow root creates an encapsulation boundary for Web Agent Markup policies. By default:

*   `wam-policy-*` attributes on ancestors of the shadow host do NOT apply to nodes within the shadow tree.
*   `wam-intent-*` attributes on ancestors of the shadow host do NOT propagate into the shadow tree.
*   Global Policy selectors (e.g., `block-selectors`, `category-rules`) do NOT match elements inside shadow trees.

Nodes within a shadow tree that lack explicit policy attributes fall back to the specification defaults, NOT to inherited values from the light DOM.

**Example (Default Behavior - No Inheritance):**

```html
<body wam-policy-input="none" wam-policy-output="readonly">
  <!-- Light DOM: hidden from LLM, readonly -->
  <my-widget>
    <!-- Shadow boundary blocks inheritance -->
    #shadow-root
      <div>
        <!-- Falls back to spec defaults: input=all, output=readonly -->
        <!-- Component content is VISIBLE to LLM despite page's input="none" -->
      </div>
  </my-widget>
</body>
```

### 10.3. Opt-In Policy Inheritance

A shadow root MAY opt into policy inheritance by specifying the `wam-policy-inherit` attribute on the shadow root's template or via the `attachShadow()` options.

**Declarative Shadow DOM:**

```html
<template shadowrootmode="open" wam-policy-inherit>
  <!-- Inherits all policy namespaces from host context -->
</template>

<template shadowrootmode="open" wam-policy-inherit="input memory">
  <!-- Inherits only specified namespaces; others use spec defaults -->
</template>
```

**Imperative Shadow DOM:**

```javascript
element.attachShadow({
  mode: 'open',
  wamPolicyInherit: true              // Inherit all namespaces
  // OR
  wamPolicyInherit: ['input', 'memory']  // Inherit specific namespaces
});
```

**Inheritance Values:**

*   `true` or empty attribute: Inherit all policy namespaces (`input`, `output`, `memory`).
*   Space-separated list (e.g., `"input memory"`): Inherit only the specified namespaces.
*   `false` or attribute absent: No inheritance (default).

### 10.4. Intersection Semantics for Inherited Policies

When a shadow root opts into inheritance, the effective policy for nodes within the shadow tree is computed as the **intersection** of:

1.  The inherited policy from the host element's context (including global policy defaults and constraints).
2.  Any local policy attributes specified within the shadow tree.

**Rule:** A permission is granted only if BOTH the inherited policy AND the local policy allow it. If either party omits or denies a permission, that permission is denied.

**Example (Intersection):**

```html
<body wam-policy-output="mutable">
  <my-widget>
    #shadow-root wam-policy-inherit
      <div wam-policy-output="style annotation">
        <!-- Inherited: mutable (all permissions) -->
        <!-- Local: style, annotation -->
        <!-- Effective: mutable ∩ (style annotation) = style annotation -->
        <!-- Component restricts page's broad permissions -->
      </div>
  </my-widget>
</body>
```

**Example (Component Restriction):**

```html
<body wam-policy-output="content annotation">
  <secure-viewer>
    #shadow-root wam-policy-inherit
      <div wam-policy-output="readonly">
        <!-- Inherited: content, annotation -->
        <!-- Local: readonly (no permissions) -->
        <!-- Effective: (content annotation) ∩ readonly = readonly -->
        <!-- Component enforces stricter policy -->
      </div>
  </secure-viewer>
</body>
```

### 10.5. Slotted Content

Slotted content presents a unique case: elements exist in the light DOM (page author's domain) but render visually within the shadow DOM (component author's domain). The effective policy for slotted content is the **intersection** of both contexts.

**Effective Policy Calculation for Slotted Elements:**

```
EffectivePolicy(slottedElement) =
    Policy(slottedElement)                    // Element's own attributes
  ∩ InheritedPolicy(lightDOMancestors)        // Light DOM inheritance chain
  ∩ SlotContextPolicy(shadowContainer)        // Shadow DOM slot container
```

**Rules:**

1.  The page author's policy on the slotted element (in light DOM) establishes a ceiling of permissions.
2.  The component author's policy on the slot's containing element establishes additional constraints.
3.  The effective policy is the intersection; both must agree for a permission to be granted.
4.  Component authors can RESTRICT what happens to slotted content but cannot EXPAND permissions beyond what the page author allowed.

**Example (Slotted Content):**

```html
<!-- Page author's light DOM -->
<my-secure-viewer>
  <p slot="content" wam-policy-output="mutable">
    Page author allows full mutability
  </p>
</my-secure-viewer>

<!-- Component author's shadow DOM -->
#shadow-root
  <div class="viewer-frame" wam-policy-output="readonly annotation">
    <slot name="content"></slot>
  </div>

<!-- Effective policy on <p>:
     Page policy (mutable) ∩ Slot context (readonly annotation)
     = annotation (only permission both agree on)
-->
```

### 10.6. Global Policy and Shadow DOM

Global Policy constraints (`block-selectors`, `category-rules`) do NOT pierce shadow boundaries by default. To apply global policies to shadow content:

1.  **Apply categories to the host element:** The page author marks the shadow host with `wam-intent-category`.
2.  **Component opts into inheritance:** The shadow root includes `wam-policy-inherit`.
3.  **Category rules propagate:** The inherited category triggers Global Policy rules within the shadow tree.

**Example:**

```html
<!-- Global Policy -->
{
  "constraints": {
    "category-rules": {
      "advertisement": { "wam-policy-input": ["none"] }
    }
  }
}

<!-- Page author marks host -->
<ad-component wam-intent-category="advertisement">
  #shadow-root wam-policy-inherit
    <div>
      <!-- Inherits category="advertisement" from host -->
      <!-- Global category-rule applies: input=none -->
      <!-- Shadow content is hidden from LLM -->
    </div>
</ad-component>
```

**Without Inheritance:**

```html
<ad-component wam-intent-category="advertisement">
  #shadow-root  <!-- No wam-policy-inherit -->
    <div>
      <!-- Category NOT inherited; global rule does NOT apply -->
      <!-- Shadow content uses spec defaults (visible) -->
      <!-- Component controls its own visibility -->
    </div>
</ad-component>
```

### 10.7. Provenance and Shadow DOM

Provenance tracking serves auditability requirements that may override normal encapsulation. The User Agent MUST track mutations across all shadow boundaries, but the level of detail disclosed is controlled by the component author.

**Mandatory Reporting:**

*   Mutations within shadow trees MUST be reported to the document's provenance ledger.
*   The User Agent MUST record that mutations occurred, even if details are not disclosed.

**Detail Level Control:**

By default, mutations within shadow roots are reported in **aggregated form** (mutation count per layer). Component authors MAY opt into full transparency.

**Declarative:**

```html
<template shadowrootmode="open" wam-provenance-transparent>
  <!-- Full mutation details reported to document ledger -->
</template>
```

**Imperative:**

```javascript
element.attachShadow({
  mode: 'open',
  wamProvenanceTransparent: true
});
```

**Ledger Entry Formats:**

*   **Default (Aggregated):**
    ```
    <my-widget> [shadow-root: 3 mutations]
      ├─ content: 2 operations
      └─ style: 1 operation
    ```
*   **Transparent (Full Detail):**
    ```
    <my-widget> [shadow-root]
      ├─ <p> content:summarized-text
      ├─ <span> content:corrected-spelling
      └─ <div> style:highlighted-warning
    ```

**Integrity Requirement:**

The User Agent MUST NOT allow component authors to completely hide that mutations occurred. Users can always determine that a shadow root contains modified content, even if specific details are aggregated.

### 10.8. Nested Shadow DOM

Each shadow boundary requires explicit opt-in for inheritance. Inheritance does NOT cascade automatically through nested shadow roots.

**Example:**

```html
<component-a>
  #shadow-root wam-policy-inherit        <!-- A inherits from page -->
    <component-b>
      #shadow-root                       <!-- B does NOT auto-inherit -->
        <div>
          <!-- Falls back to spec defaults -->
          <!-- Does NOT inherit A's effective policy -->
        </div>
    </component-b>
</component-a>
```

**For nested inheritance:**

```html
<component-a>
  #shadow-root wam-policy-inherit        <!-- A inherits from page -->
    <component-b>
      #shadow-root wam-policy-inherit    <!-- B explicitly inherits from A -->
        <div>
          <!-- Inherits A's effective policy -->
          <!-- Which already includes page's policy (intersected) -->
        </div>
    </component-b>
</component-a>
```

**Intersection Chain:**

```
Page policy
  ∩ Component A's local policy (A opted in)
  ∩ Component B's local policy (B opted in)
= Final effective policy inside B
```

### 10.9. Recommendations for Component Authors

*   **General-purpose components** (date pickers, modals, tooltips) SHOULD opt into policy inheritance (`wam-policy-inherit`) to respect page-level policies.
*   **Security-sensitive components** (password managers, payment forms, authentication widgets) SHOULD NOT inherit policies and SHOULD enforce `wam-policy-input="none"` or `wam-policy-output="readonly"` explicitly.
*   **Components displaying user-generated content** SHOULD inherit input policies but MAY enforce output restrictions.
*   **All components** SHOULD document their Web Agent Markup behavior for page authors.

